

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Order Management System</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.6/dist/JsBarcode.all.min.js"></script>
    <style>
        :root {
    --primary-color: #1976d2;
    --secondary-color: #4caf50;
    --accent-color: #2196f3;
    --danger-color: #f44336;
    --text-color: #333;
    --light-text: #e1f5fe;
    --border-color: #e3f2fd;
    --shadow-color: rgba(0, 100, 200, 0.1);
    --success-color: #4caf50;
    --warning-color: #ff5722;
}

/* Barcode styles */
.barcode {
  display: block;
  margin-top: 4px;
  width: 100px;
  height: 30px;
}

.barcode-wrapper {
  display: flex;
  gap: 8px;
  align-items: center;
  margin-top: 4px;
  white-space: nowrap;
}

.barcode-label {
  font-size: 12px;
  color: #777;
  font-weight: 500;
}

.barcode-number {
  font-size: 13px;
  font-weight: 700;
  color: #222;
  letter-spacing: 1px;
}

* { box-sizing: border-box; }

body {
    font-family: 'Segoe UI', Arial, sans-serif;
    margin: 0;
    padding: 10px;
    background-color: #f8fbff;
    min-height: 100vh;
    color: var(--text-color);
    line-height: 1.5;
}

.container {
    max-width: 100%;
    margin: 0 auto;
    background-color: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 10px var(--shadow-color);
    border: 1px solid var(--border-color);
}

.header {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-bottom: 20px;
    padding: 20px;
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
    color: white;
    border-radius: 8px;
    margin: -15px -15px 20px -15px;
}

.logo {
    font-size: 24px;
    font-weight: bold;
    color: white;
    text-align: center;
    margin: 0;
}

.customer-info { text-align: center; font-size: 14px; }
.customer-info p { margin: 5px 0; color: var(--light-text); }

.cart-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    gap: 15px;
    flex-wrap: wrap;
}

.back-button {
    padding: 8px 15px;
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
}
.back-button:hover { background-color: #1565c0; transform: translateY(-1px); }

.customer-selector { position: relative; flex-grow: 1; min-width: 200px; }
.customer-dropdown-container { position: relative; }

.customer-dropdown-container input {
    width: 100%;
    padding: 10px 40px 10px 12px;
    border: 2px solid var(--accent-color);
    border-radius: 6px;
    font-size: 14px;
    background-color: white;
    color: var(--text-color);
    transition: all 0.3s;
    height: 42px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
.customer-dropdown-container input:focus {
    outline: none;
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
}

.dropdown-arrow {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--primary-color);
    font-size: 25px;
    pointer-events: auto;
    cursor: pointer;
    transition: transform 0.2s;
}
.dropdown-arrow.open { transform: translateY(-50%) rotate(180deg); }

.custom-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 0 0 6px 6px;
    max-height: 350px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    margin-top: -1px;
}
.custom-dropdown.show { display: block; }

.dropdown-search {
    padding: 8px;
    background: white;
    position: sticky;
    top: 0;
    border-bottom: 1px solid var(--border-color);
}
.dropdown-search input {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 14px;
}
.dropdown-items-container { max-height: 300px; overflow-y: auto; }
.dropdown-item {
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
    transition: background-color 0.2s;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.dropdown-item:hover { background-color: #f5f5f5; }
.dropdown-item.selected { background-color: var(--border-color); }
.customer-name { font-weight: 600; color: var(--primary-color); font-size: 14px; }
.customer-details { font-size: 12px; color: #666; margin-top: 3px; }
.no-results { padding: 12px; color: #666; text-align: center; font-style: italic; }

.cart-icon { text-decoration: none; font-size: 24px; position: relative; color: var(--primary-color); transition: transform 0.2s; }
.cart-icon:hover { transform: scale(1.1); }
.cart-badge {
    position: absolute; top: -8px; right: -10px; min-width: 35px;
    padding: 2px 6px;
    font-size: 12px;
    background-color: var(--danger-color); color: white;
    border-radius: 50%; text-align: center;
}

.search-bar { 
    margin: 20px 0; 
    display: flex; 
    flex-direction: column; 
    gap: 10px; 
}
.search-bar input {
    width: 100%; padding: 12px; font-size: 16px; border-radius: 8px;
    border: 2px solid var(--accent-color); background-color: white; transition: border-color 0.3s;
}
.search-bar input:focus { outline: none; border-color: var(--secondary-color); }
.search-bar button {
    padding: 12px 20px;
    background: linear-gradient(135deg, var(--accent-color) 0%, var(--secondary-color) 100%);
    color: white; border: none; border-radius: 8px; cursor: pointer; transition: transform 0.2s;
    font-size: 16px; font-weight: bold;
}
.search-bar button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
#clearSearchBtn { background: linear-gradient(135deg, var(--danger-color) 0%, #e57373 100%); }

/* Price selector inline */
.price-selector-container {
  display: flex;
  align-items: center;
  gap: 6px;
  background: #ffffff;
  border-radius: 6px;
  padding: 6px 10px;
  box-shadow: 0 0 3px rgba(0, 0, 0, 0.05);
}

.price-selector-container label {
  font-size: 14px;
  color: #333;
  font-weight: 500;
}

.price-selector-container select {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  border: 1px solid #cfe8ff;
  border-radius: 6px;
  padding: 8px 32px 8px 10px;
  font-size: 14px;
  color: #333;
  cursor: pointer;
  background-color: #f9fbff;
  transition: all 0.2s ease-in-out;
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='8'><path fill='%23333' d='M1 1l5 5 5-5'/></svg>");
  background-repeat: no-repeat;
  background-position: right 10px center;
}

.price-selector-container select:hover {
  border-color: #82c1ff;
  box-shadow: 0 0 4px rgba(130, 193, 255, 0.4);
}

.price-selector-container select:focus {
  outline: none;
  border-color: #2b8af7;
  box-shadow: 0 0 4px rgba(43, 138, 247, 0.5);
}

/* ===== PRODUCT ROW - CLEAN ALIGNED LAYOUT ===== */
.product-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: white;
  border: 1px solid var(--border-color);
  border-radius: 10px;
  padding: 16px;
  box-shadow: 0 3px 10px var(--shadow-color);
  transition: all 0.2s ease;
  gap: 20px;
  margin-bottom: 15px;
}

.product-row:not(.in-cart):hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px var(--shadow-color);
  border-color: var(--accent-color);
}

.product-row.in-cart {
  background-color: #e8f5e9;
  border-left: 4px solid var(--secondary-color);
  animation: highlight 0.5s ease;
}

.product-row.in-cart:hover {
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.2);
}

@keyframes highlight { 
  from { background-color:#e8f5e9 } 
  50% { background-color:#c8e6c9 } 
  to { background-color:#e8f5e9 } 
}

.product-details { 
  flex-grow: 1; 
  min-width: 0; 
}

.product-name { 
  font-size: 16px; 
  font-weight: 600; 
  color: var(--primary-color); 
  margin-bottom: 5px; 
  white-space: nowrap; 
  overflow: hidden; 
  text-overflow: ellipsis; 
}

.product-description { 
  font-size: 14px; 
  color: #555; 
  margin-bottom: 5px; 
  white-space: nowrap; 
  overflow: hidden; 
  text-overflow: ellipsis; 
}

.product-specs { 
  font-size: 13px; 
  color: #777; 
  margin-bottom: 8px; 
}

/* ===== PRODUCT ACTIONS - PROPERLY ALIGNED ===== */
.product-actions {
  display: flex;
  align-items: center;
  gap: 12px;
  flex-shrink: 0;
  flex-wrap: nowrap;
}

/* Editable price group */
.editable-price-group {
  display: flex;
  align-items: center;
  gap: 6px;
  background: #fff8e1;
  padding: 6px 10px;
  border-radius: 6px;
  box-shadow: 0 1px 4px rgba(255, 152, 0, 0.2);
  flex-shrink: 0;
}

.editable-price-group label {
  font-size: 13px;
  font-weight: 600;
  color: var(--primary-color);
  white-space: nowrap;
}

.editable-price-group input,
input[id^="editablePrice-"] {
  width: 90px;
  padding: 6px 8px;
  border: 2px solid var(--accent-color);
  border-radius: 6px;
  font-size: 14px;
  text-align: right;
  font-weight: 700;
  color: var(--primary-color);
  background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
  box-shadow: 0 2px 6px rgba(255, 152, 0, 0.2);
  transition: all 0.2s;
}

.editable-price-group input:focus,
input[id^="editablePrice-"]:focus {
  outline: none;
  border-color: var(--warning-color);
  background: linear-gradient(135deg, #fff9c4 0%, #ffecb3 100%);
  box-shadow: 0 0 0 2px rgba(255, 152, 0, 0.2);
}

.editable-price-group input:hover,
input[id^="editablePrice-"]:hover {
  border-color: var(--warning-color);
  box-shadow: 0 3px 8px rgba(255, 152, 0, 0.3);
}

/* Quantity controls */
.quantity-controls {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-shrink: 0;
}

.quantity-controls button {
  width: 32px;
  height: 32px;
  border: 2px solid var(--accent-color);
  background-color: white;
  color: var(--accent-color);
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 16px;
  transition: all 0.2s;
  flex-shrink: 0;
}

.quantity-controls button:hover {
  background: linear-gradient(135deg, var(--accent-color) 0%, var(--secondary-color) 100%);
  color: white;
  border-color: var(--secondary-color);
  transform: scale(1.05);
}

.quantity-controls button:disabled {
  border-color: #ccc;
  color: #ccc;
  cursor: not-allowed;
  background: white;
}

.quantity-display {
  background: linear-gradient(135deg, #f3f9ff 0%, #e8f8f5 100%);
  padding: 6px 12px;
  border-radius: 6px;
  font-weight: bold;
  min-width: 60px;
  text-align: center;
  color: var(--primary-color);
  border: 2px solid var(--accent-color);
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}

.quantity-display:hover {
  background: linear-gradient(135deg, #e3f2fd 0%, #d4edf7 100%);
  transform: scale(1.02);
}

.quantity-input {
  background: linear-gradient(135deg, #f3f9ff 0%, #e8f8f5 100%);
  padding: 6px 12px;
  border-radius: 6px;
  font-weight: bold;
  width: 80px;
  text-align: center;
  color: var(--primary-color);
  border: 2px solid var(--accent-color);
  font-size: 14px;
  outline: none;
}

/* Add to cart button */
.add-to-cart-btn {
  padding: 8px 16px;
  background: linear-gradient(135deg, var(--warning-color) 0%, #d84315 100%);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  transition: all 0.2s;
  box-shadow: 0 2px 6px rgba(255, 87, 34, 0.3);
  white-space: nowrap;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.add-to-cart-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(255, 87, 34, 0.4);
}

.add-to-cart-btn:disabled {
  background: linear-gradient(135deg, #ccc 0%, #ddd 100%);
  cursor: not-allowed;
  box-shadow: none;
  transform: none;
  opacity: 0.7;
}

.add-to-cart-btn::after {
  content: "Add";
}

/* Eye icon for price details */
.view-prices-btn {
  background: linear-gradient(135deg, #2196f3 0%, #4caf50 100%);
  color: white;
  border: none;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s;
  box-shadow: 0 2px 6px rgba(33, 150, 243, 0.3);
  flex-shrink: 0;
}

.view-prices-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 4px 10px rgba(33, 150, 243, 0.5);
}

/* Price popup */
.price-popup-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 3000;
  padding: 15px;
}

.price-popup-content {
  background: white;
  padding: 25px;
  border-radius: 12px;
  width: 100%;
  max-width: 450px;
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
}

.price-popup-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 2px solid var(--border-color);
}

.price-popup-header h3 {
  margin: 0;
  color: var(--primary-color);
  font-size: 20px;
}

.price-popup-close {
  background: var(--danger-color);
  color: white;
  border: none;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 20px;
  font-weight: bold;
  transition: all 0.2s;
}

.price-popup-close:hover {
  transform: scale(1.1);
  box-shadow: 0 2px 8px rgba(244, 67, 54, 0.4);
}

.price-popup-product-info {
  margin-bottom: 20px;
  padding: 15px;
  background: linear-gradient(135deg, #f3f9ff 0%, #e8f8f5 100%);
  border-radius: 8px;
  border-left: 4px solid var(--secondary-color);
}

.price-popup-product-info .product-name {
  font-size: 18px;
  font-weight: 700;
  color: var(--primary-color);
  margin-bottom: 5px;
}

.price-popup-product-info .product-code {
  font-size: 14px;
  color: #666;
}

.price-popup-prices {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.price-popup-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 15px;
  background: white;
  border: 2px solid var(--border-color);
  border-radius: 8px;
  transition: all 0.2s;
}

.price-popup-item:hover {
  border-color: var(--accent-color);
  box-shadow: 0 2px 8px rgba(33, 150, 243, 0.15);
}

.price-popup-item.selected {
  background: linear-gradient(135deg, #e3f2fd 0%, #d4edf7 100%);
  border-color: var(--secondary-color);
  border-width: 3px;
}

.price-popup-label {
  font-weight: 600;
  color: var(--text-color);
  font-size: 15px;
}

.price-popup-value {
  font-size: 16px;
  font-weight: 700;
  color: var(--secondary-color);
}

.success-message {
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    background: linear-gradient(135deg, var(--success-color) 0%, #66bb6a 100%);
    color: white; padding: 15px 20px; border-radius: 8px; z-index: 1000; 
    box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    animation: slideIn 0.3s ease-out; text-align: center; max-width: 90%;
}
@keyframes slideIn { 
  from{transform:translateX(-50%) translateY(-100%); opacity:0} 
  to{transform:translateX(-50%) translateY(0); opacity:1} 
}

.loading-spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid var(--accent-color);
    border-radius: 50%;
    width: 40px; height: 40px;
    animation: spin 1s linear infinite;
    margin: 20px auto;
}
@keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }

.pagination { 
  display: flex; 
  justify-content: center; 
  margin-top: 20px; 
  gap: 5px; 
  flex-wrap: wrap; 
}
.pagination button {
    padding: 8px 12px; background-color: #f0f0f0; border: 1px solid #ddd; 
    border-radius: 4px; cursor: pointer; transition: all 0.2s;
}
.pagination button:hover { background-color: #e0e0e0; }
.pagination button.active { 
  background-color: var(--primary-color); 
  color: white; 
  border-color: var(--primary-color); 
}
.pagination button:disabled { opacity: 0.5; cursor: not-allowed; }

.page-info { text-align: center; margin-top: 10px; color: #666; font-size: 14px; }

/* Customer popup */
.popup-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.5);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  padding: 15px;
}
.popup-content {
  background: #fff;
  padding: 20px;
  border-radius: 10px;
  width: 100%;
  max-width: 400px;
  box-shadow: 0 5px 15px rgba(0,0,0,.3);
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.popup-content h3 {
  margin: 0 0 10px 0;
  color: var(--primary-color);
  font-size: 18px;
  text-align: center;
}
.popup-content input {
  width: 100%;
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 6px;
  font-size: 16px;
}
.popup-actions {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 10px;
}
.popup-actions button {
  flex: 1; 
  padding: 12px; 
  border: 0; 
  border-radius: 6px; 
  font-weight: 700; 
  color: #fff; 
  font-size: 16px; 
  cursor: pointer;
}
.popup-actions button:first-child { background: var(--secondary-color); }
.popup-actions button:last-child { background: var(--danger-color); }

/* ===== MOBILE RESPONSIVE ===== */
@media only screen and (max-width: 768px) {
    body { padding: 8px; }
    .container { padding: 10px; }
    .header { padding: 15px; margin: -10px -10px 15px -10px; gap: 10px; }
    .logo { font-size: 20px; }
    .customer-info { font-size: 13px; }
    .cart-header { gap: 10px; }
    .customer-selector { order: 3; width: 100%; margin-top: 10px; }
    
    .search-bar { flex-direction: column; }
    .search-bar input, .search-bar button { width: 100%; font-size: 14px; }
    
    .price-selector-container {
      width: 100%;
      justify-content: flex-start;
      margin-top: 10px;
    }
    
    .product-row { 
      flex-direction: column; 
      align-items: stretch; 
      padding: 12px; 
      gap: 12px; 
    }
    
    .product-actions { 
      width: 100%; 
      justify-content: space-between; 
      flex-wrap: wrap; 
      gap: 10px; 
    }
    
    .editable-price-group { 
      width: 100%; 
      justify-content: space-between; 
    }
    
    .editable-price-group input { width: 120px; }
    
    .quantity-controls { 
      justify-content: center; 
    }
    
    .add-to-cart-btn { 
      width: 100%;
    }
    
    .add-to-cart-btn::after {
      content: "Add to Cart";
    }
    
    .product-name { font-size: 15px; }
    .quantity-controls button { width: 28px; height: 28px; font-size: 13px; }
    .quantity-display, .quantity-input { font-size: 13px; min-width: 60px; }
}

/* ===== DESKTOP ===== */
@media only screen and (min-width: 769px) {
    .container { max-width: 900px; margin: 0 auto; }
    .header { 
      flex-direction: row; 
      justify-content: space-between; 
      align-items: center; 
      padding: 20px; 
    }
    .customer-info { text-align: right; }
    .search-bar { flex-direction: row; align-items: center; }
    .search-bar input { flex: 1; }
    .search-bar button { min-width: 100px; }
    
    .product-actions { 
      flex-direction: row; 
    }
    
    .add-to-cart-btn::after {
      content: "Add to Cart";
    }
}

</style>
<body>
<!-- Customer Popup Modal (single copy) -->
<div id="customerPopup" class="popup-overlay">
  <div class="popup-content">
    <h3>Add New Customer</h3>
    <input type="text" id="customerName" placeholder="Enter Name" required>
    <input type="text" id="customerPlace" placeholder="Enter Place">
    <input type="text" id="customerPhone" placeholder="Enter Phone">
    <div class="popup-actions">
      <button id="saveCustomerBtn">Save</button>
      <button id="cancelPopupBtn">Cancel</button>
    </div>
  </div>
</div>

<!-- Price Details Popup -->
<div id="pricePopup" class="price-popup-overlay">
  <div class="price-popup-content">
    <div class="price-popup-header">
      <h3>Price Details</h3>
      <button class="price-popup-close" onclick="closePricePopup()">√ó</button>
    </div>
    <div class="price-popup-product-info">
      <div class="product-name" id="popupProductName"></div>
      <div class="product-code" id="popupProductCode"></div>
    </div>
    <div class="price-popup-prices" id="popupPricesList"></div>
  </div>
</div>

<div class="container">
  <div class="header">
    <div class="logo">Order Management</div>
    <div class="customer-info">
      <p><strong>Customer Name: <span id="displayCustomerName"></span></strong></p>
      <p><span id="displayCustomerPlace"></span></p>
      <p><span id="displayCustomerPhone"></span></p>
      <p>Date: <span id="currentDate"></span></p>
    </div>
  </div>

  <div class="cart-header">
    <button onclick="confirmBack()" class="back-button">‚Üê Back</button>
    <button onclick="refreshOrderPage()" class="back-button" style="background-color:#ff5722;">‚ü≥ Refresh</button>


    <div class="customer-selector">
      <div class="customer-dropdown-container">
        <input
          type="text"
          name="customer"
          id="customerSelector"
          placeholder="Select customer..."
          required
          autocomplete="off"
          aria-autocomplete="list"
          aria-controls="customerDropdown"
          aria-expanded="false"
        />
       <div class="dropdown-arrow" tabindex="0" role="button" aria-label="Add New Customer">‚ûï</div>




        <div class="custom-dropdown" id="customerDropdown" role="listbox">
          <div class="dropdown-search">
            <input type="text" placeholder="Search customers..." aria-label="Search customers" class="dropdown-search-input" />
          </div>
          <div class="dropdown-items-container">
            <!-- Items populated dynamically -->
          </div>
        </div>
      </div>
    </div>

    <a href="{% url 'cart' %}" class="cart-icon">
      üõí
      <span id="cartBadge" class="cart-badge">0</span>
    </a>
  </div>

<div class="search-bar">
  <input
    type="text"
    id="searchInput"
    placeholder="Search Product or Enter Code (e.g., 00001)"
  />
  <button onclick="searchProduct()">Search</button>
  <button onclick="clearSearch()" id="clearSearchBtn" style="display: none;">Clear</button>

  <!-- PRICE SELECTOR: styled and aligned inline -->
  <div class="price-selector-container">
    <label for="priceSelector">Price:</label>
    <select id="priceSelector" aria-label="Select price type">
     
      <option value="salesprice">Sales Price</option>
      <option value="bmrp">BMRP</option>
      <option value="secondprice">Second Price</option>
      <option value="thirdprice">Third Price</option>
    </select>
  </div>
</div>

<!-- Product and pagination sections remain below -->
<div class="product-list" id="productList">
  <div class="loading-spinner" id="loadingSpinner"></div>
</div>

<div class="pagination" id="pagination"></div>
<div class="page-info" id="pageInfo"></div>



 <script>
/* =========================
   State
========================= */
let products = [];
let cartQuantities = {};
let selectedQuantities = {};
let currentPage = 1;
const itemsPerPage = 10;
let isSearching = false;
let searchTerm = '';
let customerList = [];
let serverCartQuantities = {}; // { [product_code]: qty currently in the cart }


let selectedPriceKey = 'salesprice';

const PRICE_ORDER = ['cost','salesprice','bmrp','secondprice','thirdprice','fourthprice'];



function mostCommon(arr) {
  const cnt = new Map();
  for (const v of arr) if (v) cnt.set(v, (cnt.get(v) || 0) + 1);
  let best = null, max = 0;
  for (const [k, c] of cnt) if (c > max) { best = k; max = c; }
  return best;
}

function derivePriceLabels(products) {
  const nameFields = {
    cost: 'cost_name',
    salesprice: 'sales_price_name',
    bmrp: 'bmrp_name',
    secondprice: 'secondprice_name',
    thirdprice: 'thirdprice_name',
    fourthprice: 'fourthprice_name',
  };
  const labels = {};
  for (const key of Object.keys(nameFields)) {
    const col = nameFields[key];
    const vals = (products || []).map(p => p?.batch?.[col] || '').filter(Boolean);
    labels[key] = mostCommon(vals) || '';     // if no DB name => hide tier in dropdown
  }
  return labels;
}

function rebuildPriceSelector(labels) {
  const sel = document.getElementById('priceSelector');
  if (!sel) return;
  const options = [];

  for (const k of PRICE_ORDER) {
    const label = labels[k];
    if (label) options.push({ key: k, label });
  }
  sel.innerHTML = options.map(o => `<option value="${o.key}">${o.label}</option>`).join('');
  if (!options.some(o => o.key === selectedPriceKey)) selectedPriceKey = 'all';
  sel.value = selectedPriceKey;
  sel.onchange = e => setSelectedPriceKey(e.target.value);
}

function priceRowHTML(batch, key, nameField) {
  const label = batch?.[nameField];
  const val = batch?.[key];
  if (!label) return ''; // no DB name => hide the tier completely
  const txt = (val != null && val !== '') ? Number(val).toLocaleString() : '‚Äî';
  return `
    <div class="price-item" data-key="${key}" style="font-size:14px; margin:2px 0;">
      <strong>${escapeHtml(label)}:</strong> ‚Çπ${txt}
    </div>`;
}


function getSelectedPriceKey(){ return selectedPriceKey; }
function setSelectedPriceKey(key){ selectedPriceKey = key || 'all'; applyPriceSelectionToProducts(); }
// Initialize editable price inputs and attach listeners
products.forEach(product => {
  if (!product.code) return;
  const input = document.getElementById(`editablePrice-${product.code}`);
  if (!input) return;

  // set initial value based on current selected price key
  const chosenKey = getSelectedPriceKey();
  const baseValue = getPriceFromBatch(product.batch, chosenKey);
  if (baseValue && baseValue !== 0) input.value = Number(baseValue).toFixed(2);
  else input.value = '';

  // store edited price in product.__edited so other code can access it
 // --- Show warning if product is already in the cart, but still allow editing ---
input.addEventListener('focus', () => {
  const inCartQty = Number(serverCartQuantities[product.code] || 0);
  if (inCartQty > 0) {
    showErrorMessage(
      `‚ö†Ô∏è "${product.name || product.code}" is already in the cart (Qty: ${inCartQty}). Editing the price will only apply to new additions.`
    );
  }
});

// --- Normal input handler: always accept typed edits ---
input.addEventListener('input', () => {
  const v = parseFloat(input.value);
  if (!product.__edited) product.__edited = {};
  product.__edited.unit_price = (!isNaN(v) && v >= 0) ? Number(v.toFixed(2)) : null;
});

});

function initPriceSelector(){
  const sel = document.getElementById('priceSelector');
  if (!sel) return;
  sel.value = selectedPriceKey;

  sel.addEventListener('change', e => {
    const newCategory = e.target.value;

    // Check if cart has any items
    const cartHasItems = Object.values(serverCartQuantities || {}).some(qty => qty > 0);
    if (cartHasItems) {
      // Revert dropdown to previous value
      e.target.value = selectedPriceKey;

      // Show warning
      showErrorMessage("‚ö†Ô∏è You already have products in your cart. Please clear the cart before changing price category.");
      return;
    }

    // If cart empty, allow change
    setSelectedPriceKey(newCategory);
  });
}

function applyPriceSelectionToProducts(){
  const chosen = getSelectedPriceKey();
  products = Array.isArray(products) ? products : [];

  products.forEach(p => {
    if (!p.code) return;
    const container = document.getElementById(`prices-${p.code}`);
    if (container) {
      // --- existing logic: show/hide price rows based on selected key ---
      container.querySelectorAll('.price-item').forEach(item => {
        const key = item.getAttribute('data-key');
        if (chosen === 'all') {
          item.style.display = 'block';
          item.style.fontWeight = '400';
          item.style.opacity = '1';
        } else {
          if (key === chosen) {
            item.style.display = 'block';
            item.style.fontWeight = '700';
            item.style.opacity = item.textContent.includes('‚Äî') ? '0.6' : '1';
          } else {
            item.style.display = 'none';
          }
        }
      });
    }

    // --- UPDATED LOGIC: Always populate editable price input when category is selected ---
    const editEl = document.getElementById(`editablePrice-${p.code}`);
    if (editEl) {
      if (chosen && chosen !== 'all') {
        // Get the price value for the selected category
        let val = getPriceFromBatch(p.batch, chosen);
        
        // Always show the value (even if 0) so user can see and edit it
        editEl.value = (val != null) ? Number(val).toFixed(2) : '0.00';
        
        // clear any previously cached manual edit, because category changed
        if (p.__edited) p.__edited.unit_price = null;
      } else {
        // if 'all' is selected, clear edit box (no specific price selected)
        editEl.value = '';
        if (p.__edited) p.__edited.unit_price = null;
      }
    }
  });
}

/* ‚úÖ Add this helper right below */
// Returns the best numeric price from a batch according to chosenKey and fallbacks.
function getPriceFromBatch(batch, chosenKey) {
  if (!batch) {
    // no batch info ‚Äî treat as zero price
    return 0;
  }

  // If a specific price key is selected (not 'all')
  if (chosenKey && chosenKey !== 'all') {
    const val = batch[chosenKey];
    if (val != null && val !== '') {
      const n = Number(val);
      if (!Number.isNaN(n)) return n;
    }
    // fall through to fallback order if selected key missing/invalid
  }

  // Fallback order for first available valid price
  const order = ['cost','salesprice','bmrp','secondprice','thirdprice','fourthprice'];
  for (const k of order) {
    const v = batch[k];
    if (v != null && v !== '') {
      const n = Number(v);
      if (!Number.isNaN(n)) return n;
    }
  }

  // nothing usable found
  return 0;
}

// Returns Number (two-decimal) or null if user did not provide a valid edited price.
// Looks at product.__edited first, then DOM input `editablePrice-<code>`.
function getEditedPrice(code) {
  if (typeof products !== 'undefined' && Array.isArray(products)) {
    const p = products.find(x => x.code === code);
    if (p && p.__edited && p.__edited.unit_price != null) {
      const v = Number(p.__edited.unit_price);
      return Number.isFinite(v) && v >= 0 ? Number(v.toFixed(2)) : null;
    }
  }
  const el = document.getElementById(`editablePrice-${code}`);
  if (!el) return null;
  const v = parseFloat(el.value);
  if (isNaN(v) || v < 0) return null;
  return Number(v.toFixed(2));
}

/* =========================
   Navigation
========================= */
function confirmBack() {
  if (confirm("Are you sure you want to go back? Unsaved changes may be lost.")) {
    window.history.back();
    clearCart();
  }
}

function refreshOrderPage() {
  if (confirm("Refreshing will clear the current customer and cart. Continue?")) {
    localStorage.removeItem('selected_customer');
    localStorage.removeItem('cartData');
    location.reload();
  }
}


/* =========================
   Util / UI helpers
========================= */
function $(id){ return document.getElementById(id); }

function getCurrentCustomerName() {
  return JSON.parse(localStorage.getItem('selected_customer') || '{}').name || 'Guest';
}
function getCustomerCart() {
  const all = JSON.parse(localStorage.getItem('cartData') || '{}');
  const cust = getCurrentCustomerName();
  if (!all[cust]) all[cust] = {};
  return all[cust];
}
function setCustomerCart(obj) {
  const all = JSON.parse(localStorage.getItem('cartData') || '{}');
  all[getCurrentCustomerName()] = obj;
  localStorage.setItem('cartData', JSON.stringify(all));
}
function escapeHtml(unsafe) {
  if (!unsafe) return '';
  return unsafe.toString()
    .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function showLoading(show) {
  const el = $('loadingSpinner');
  if (el) el.style.display = show ? 'block' : 'none';
}
function showSuccessMessage(message) {
  const successDiv = document.createElement('div');
  successDiv.className = 'success-message';
  successDiv.textContent = message;
  document.body.appendChild(successDiv);
  setTimeout(() => successDiv.remove(), 3000);
}
function showErrorMessage(message) {
  const errorDiv = document.createElement('div');
  errorDiv.className = 'success-message';
  errorDiv.style.background = 'linear-gradient(135deg, #f44336 0%, #e57373 100%)';
  errorDiv.textContent = message;
  document.body.appendChild(errorDiv);
  setTimeout(() => errorDiv.remove(), 3000);
}

/* =========================
   Price Popup Functions
========================= */
function showPricePopup(productCode) {
  const product = products.find(p => p.code === productCode);
  if (!product) return;

  const popup = $('pricePopup');
  if (!popup) return;

  // Set product info
  const nameEl = $('popupProductName');
  const codeEl = $('popupProductCode');
  if (nameEl) nameEl.textContent = product.name || 'N/A';
  if (codeEl) codeEl.textContent = `Code: ${product.code || 'N/A'}`;

  // Build price list
  const pricesList = $('popupPricesList');
  if (!pricesList) return;
  const batch = product.batch || {};
  const selectedKey = getSelectedPriceKey();

  // Read actual keys from the price selector dropdown (trust the selector).
  const sel = document.getElementById('priceSelector');
  const availableKeys = sel
    ? Array.from(sel.options).map(o => o.value).filter(v => v && v !== 'all')
    : [];

  // Use only names that come from the batch (no generic fallbacks).
  const priceItems = [
    { key: 'cost',       label: batch.cost_name || '',         value: batch.cost },
    { key: 'salesprice', label: batch.sales_price_name || '', value: batch.salesprice },
    { key: 'bmrp',       label: batch.bmrp_name || '',         value: batch.bmrp },
    { key: 'secondprice',label: batch.secondprice_name || '', value: batch.secondprice },
    { key: 'thirdprice', label: batch.thirdprice_name || '',  value: batch.thirdprice },
    { key: 'fourthprice',label: batch.fourthprice_name || '', value: batch.fourthprice }
  ];

  // Only show:
  //  - tiers that the dropdown exposes (availableKeys), OR
  //  - if we couldn't read the selector (availableKeys empty), fall back to only those with a real batch label
  const filtered = priceItems.filter(item => {
    if (!item.label) return false; // if there's no DB label, hide it (no fallback)
    if (availableKeys.length > 0) {
      return availableKeys.includes(item.key);
    }
    return !!item.label;
  });

  // Render rows; highlight the active selectedKey if it matches
  pricesList.innerHTML = filtered.map(item => {
    const isSelected = (selectedKey === item.key);
    const displayValue = (item.value != null && item.value !== '')
      ? `‚Çπ${Number(item.value).toLocaleString()}`
      : '‚Äî';
    return `
      <div class="price-popup-item ${isSelected ? 'selected' : ''}">
        <span class="price-popup-label">${escapeHtml(item.label)}</span>
        <span class="price-popup-value">${displayValue}</span>
      </div>
    `;
  }).join('');

  popup.style.display = 'flex';
}


function closePricePopup() {
  const popup = $('pricePopup');
  if (popup) popup.style.display = 'none';
}


/* =========================
   Products / Cart
========================= */
async function fetchProducts() {
  try {
    showLoading(true);
    const token = localStorage.getItem('access_token');
    if (!token) {
      showErrorMessage("Please login first");
      return;
    }

    const response = await fetch('/products/', {
      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(error || "Server returned an error");
    }

    const data = await response.json();
    products = (data.results || []).map(p => ({
      ...p,
      batch: p.batch || null
    }));

    // ‚úÖ Build dynamic dropdown names from DB
    const labels = derivePriceLabels(products);
    rebuildPriceSelector(labels);

    // init qty maps
    products.forEach(product => {
      if (!product.code) return;
      cartQuantities[product.code] = cartQuantities[product.code] || 0;
      selectedQuantities[product.code] = selectedQuantities[product.code] || 0;
    });

    loadCartFromLocalStorage();
    loadProducts();
    updateCartBadge();
    setupPagination();
  } catch (error) {
    console.error("Fetch error:", error);
    products = [];
    showErrorMessage(error.message || "Failed to load products");
    const list = $('productList');
    if (list) {
      list.innerHTML =
        '<div style="text-align: center; padding: 20px; color: #666;">' +
        (error.message || "Failed to load products. Please try again.") + '</div>';
    }
  } finally {
    showLoading(false);
  }
}

function loadCartFromLocalStorage() {
  // Reset current session quantities
  cartQuantities = {};
  selectedQuantities = {};
  products.forEach(p => {
    if (p.code) {
      cartQuantities[p.code] = 0;
      selectedQuantities[p.code] = 0;
    }
  });

  // Update badge + highlights from server
  updateCartBadge();
  updateProductHighlights();
}

function saveCartToLocalStorage() {
  const existing = getCustomerCart();

  // Add new selections on top of existing
  Object.keys(cartQuantities).forEach(code => {
    if (cartQuantities[code] > 0) {
      existing[code] = (existing[code] || 0) + cartQuantities[code];
    }
  });

  setCustomerCart(existing);

  // reset temp selections
  cartQuantities = {};
  selectedQuantities = {};
  products.forEach(p => {
    if (p.code) {
      cartQuantities[p.code] = 0;
      selectedQuantities[p.code] = 0;
    }
  });

  updateCartBadge();
  updateProductHighlights();
}


function loadProducts() {
  const productList = $('productList');
  if (!productList) return;
  productList.innerHTML = '';

  if (!Array.isArray(products)) { console.error("Products data is not an array!"); products = []; }

  if (products.length === 0) {
    productList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No products available</div>';
    return;
  }

  let productsToDisplay = products;
  if (isSearching && searchTerm) {
    productsToDisplay = products.filter(product =>
      (product.name && product.name.toLowerCase().includes(searchTerm)) ||
      (product.code && product.code.toLowerCase().includes(searchTerm)) ||
      (product.brand && product.brand.toLowerCase().includes(searchTerm)) ||
      (product.product && product.product.toLowerCase().includes(searchTerm))
    );
  }

  if (productsToDisplay.length === 0) {
    productList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No products found</div>';
    if ($('pagination')) $('pagination').innerHTML = '';
    if ($('pageInfo')) $('pageInfo').innerHTML = '';
    return;
  }

  let paginatedProducts = productsToDisplay;
  if (!isSearching) {
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, productsToDisplay.length);
    paginatedProducts = productsToDisplay.slice(startIndex, endIndex);
  }

  paginatedProducts.forEach(product => {
    if (!product.code) return;

    const productRow = document.createElement('div');
    productRow.className = 'product-row';
    productRow.id = `product-${product.code}`;
    if (cartQuantities[product.code] > 0) productRow.classList.add('in-cart');

    let description = '';
    if (product.product) description += product.product;
    if (product.brand) description += (description ? ' - ' : '') + product.brand;
    if (product.unit) description += (description ? ' ' : '') + product.unit;


productRow.innerHTML = `
  <div class="product-details">
    <div style="display:flex; align-items:center; gap:20px; margin-bottom:5px;">
      <div class="product-name" style="margin:0;">${escapeHtml(product.name || '')}</div>
      <!-- Eye icon next to product name -->
      <button class="view-prices-btn" onclick="showPricePopup('${product.code}')" title="View all prices"
              style="margin:0; width:24px; height:24px; flex-shrink:0; padding:0; font-size:16px;">
        üëÅÔ∏è
      </button>
    </div>
    <div class="product-description">${escapeHtml(description)}</div>
    <div class="product-specs">Code: ${escapeHtml(product.code || '')}</div>
    <div id="barcode-${product.code}" class="barcode-placeholder"></div>


  </div>

  <!-- Better spaced horizontal layout -->
  <div class="product-actions" style="display:flex; align-items:center; gap:15px; flex-wrap:nowrap; justify-content:flex-end;">
    
    <!-- Editable price input -->
    <div class="editable-price-group">
  <label for="editablePrice-${product.code}">Edit Price:</label>
  <input id="editablePrice-${product.code}" type="number" step="0.01" min="0"
         placeholder="Enter price"
         title="Edit price" />
</div>


    <!-- Quantity controls and Add to Cart grouped together closely -->
    <div style="display:flex; align-items:center; gap:6px;">
      <div class="quantity-controls" style="margin:0; display:flex; gap:6px; align-items:center;">
        <button onclick="changeSelectedQuantity('${product.code}', -1)" ${selectedQuantities[product.code] <= 0 ? 'disabled' : ''}>-</button>
        <div class="quantity-display" id="qty-${product.code}" onclick="enableQuantityInput('${product.code}')">${selectedQuantities[product.code] || 0}</div>
        <button onclick="changeSelectedQuantity('${product.code}', 1)">+</button>
      </div>

      <!-- Add to Cart button (smaller) -->
      <button class="add-to-cart-btn" onclick="addToCart('${product.code}')"
              ${selectedQuantities[product.code] <= 0 ? 'disabled' : ''}
              title="Add ${selectedQuantities[product.code]} to Cart"
              style="width:auto !important; height:34px !important; padding:6px 12px !important; font-size:13px !important; white-space:nowrap !important;"></button>
    </div>
  </div>


`;    productList.appendChild(productRow);

   // ‚úÖ Show only barcode number under "Code:" (replace SVG with plain text)
(function() {
  const barcodeValue = (product.batch && product.batch.barcode) || product.barcode || null;
  const svgId = `barcode-${product.code}`;
  const svgEl = document.getElementById(svgId);

  if (!svgEl) return; // nothing to render into

  if (!barcodeValue) {
    // hide if no barcode
    svgEl.style.display = 'none';
    return;
  }

try {
  // Replace SVG node with an inline labeled barcode (Label and number on one line)
  svgEl.outerHTML = `
    <div class="barcode-wrapper">
      <span class="barcode-label">Barcode:</span>
      <span class="barcode-number">${escapeHtml(String(barcodeValue || '‚Äî'))}</span>
    </div>
  `;
} catch (err) {
  console.warn('Barcode replacement error for', product.code, err);
  try { svgEl.style.display = 'none'; } catch (e) {}
}


})();
  });

  // ‚úÖ Handle pagination & search info
  if (isSearching) {
    if ($('pagination')) $('pagination').innerHTML = '';
    if ($('pageInfo')) $('pageInfo').innerHTML = `Showing ${productsToDisplay.length} search results`;
  } else {
    setupPagination();
    updatePageInfo();
    applyPriceSelectionToProducts();
  }
}



/* =========================
   Qty editing
========================= */
function enableQuantityInput(productCode) {
  if (!isCustomerSelected()) { showErrorMessage("‚ö†Ô∏è Please select a customer first"); return; }
  const qtyElement = $(`qty-${productCode}`);
  if (!qtyElement) return;

  const currentValue = selectedQuantities[productCode] ?? 0;
  const input = document.createElement('input');
  input.type = 'number';
  input.className = 'quantity-input';
  input.value = currentValue;
  input.min = '0';
  input.step = '0.001';           // üëà allow fractional steps
  input.inputMode = 'decimal';     // mobile keyboard
  input.pattern = '[0-9]*[.]?[0-9]*';

  input.onblur     = () => updateQuantityFromInput(productCode, input);
  input.onkeypress = (e) => { if (e.key === 'Enter') updateQuantityFromInput(productCode, input); };

  qtyElement.replaceWith(input);
  input.focus(); input.select();
}

function updateQuantityFromInput(productCode, inputElement) {
  let newValue = parseFloat(inputElement.value);
  if (Number.isNaN(newValue) || newValue < 0) newValue = 0;

  // keep up to 3 decimals to match DB
  newValue = +newValue.toFixed(3);

  selectedQuantities[productCode] = newValue;

  const displayElement = document.createElement('div');
  displayElement.className = 'quantity-display';
  displayElement.id = `qty-${productCode}`;
  displayElement.textContent = newValue;
  displayElement.onclick = () => enableQuantityInput(productCode);
  inputElement.replaceWith(displayElement);

  updateQuantityButtons(productCode);
  updateAddToCartButton(productCode);
}

function changeSelectedQuantity(productCode, change) {
  if (!isCustomerSelected()) { showErrorMessage("‚ö†Ô∏è Please select a customer first"); return; }
  const newQuantity = (selectedQuantities[productCode] || 0) + change;
  if (newQuantity >= 0) {
    selectedQuantities[productCode] = newQuantity;
    updateQuantityDisplay(productCode);
    updateQuantityButtons(productCode);
    updateAddToCartButton(productCode);
  }
}
function updateQuantityDisplay(productCode) {
  const qtyElement = $(`qty-${productCode}`);
  if (qtyElement) qtyElement.textContent = selectedQuantities[productCode] || 0;
}
function updateQuantityButtons(productCode) {
  const productRow = $(`product-${productCode}`);
  if (productRow) {
    const decreaseBtn = productRow.querySelector('.quantity-controls button');
    if (decreaseBtn) decreaseBtn.disabled = (selectedQuantities[productCode] || 0) <= 0;
  }
}
function updateAddToCartButton(productCode) {
  const row = $(`product-${productCode}`);
  if (!row) return;
  const btn = row.querySelector('.add-to-cart-btn');
  if (!btn) return;

  const desired = selectedQuantities[productCode] || 0;
  const current = serverCartQuantities[productCode] || 0;
  const delta = desired - current;

  btn.disabled = delta <= 0;
  btn.title = delta > 0 ? `Add ${delta} more` : `No change`;
}

/* =========================
   Server cart sync
========================= */
/* =========================
   Server cart sync
========================= */
async function addToCart(productCode) {
  // --- require customer + explicit price category ---
  if (!isCustomerSelected()) {
    showErrorMessage("‚ö†Ô∏è Please select a customer first");
    return;
  }
  const chosenKey = getSelectedPriceKey();
  if (!chosenKey || chosenKey === 'all') {
    showErrorMessage("‚ö†Ô∏è Please select a Price Category before adding to cart");
    return;
  }

  const desiredQty = parseFloat(selectedQuantities[productCode] ?? 0);
  const currentServerQty = parseFloat(serverCartQuantities[productCode] ?? 0);
  const delta = +(desiredQty - currentServerQty).toFixed(3);

  if (delta <= 0) {
    showSuccessMessage?.("No change ‚Äî quantity already in cart");
    return;
  }

  try {
    const customer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
    const product = products.find(p => p.code === productCode);
    if (!product) { showErrorMessage("Product not found"); return; }

    // Prefer edited price (user input). Fallback to selected price key and then the fallback order.
    let chosenUnitPrice = getEditedPrice(productCode);
    if (chosenUnitPrice == null) {
      chosenUnitPrice = getPriceFromBatch(product.batch, chosenKey);
    }

    if (!Number.isFinite(chosenUnitPrice) || chosenUnitPrice < 0) chosenUnitPrice = 0;
    chosenUnitPrice = Number(chosenUnitPrice.toFixed(2));

    const cartData = {
      user_id: localStorage.getItem("user_id"),
      client_id: localStorage.getItem("client_id"),
      customer_name: customer.name || 'Guest',
      customer_phone: customer.phone || '',
      customer_address: customer.address || '',
      product_code: productCode,
      quantity: delta,
      price_key: chosenKey,
      unit_price: chosenUnitPrice
    };

    console.log("DEBUG addToCart payload:", cartData);

    const response = await fetch('/api/cart/add/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(cartData)
    });

    const data = await response.json();
    if (data.success) {
      serverCartQuantities[productCode] = desiredQty;
      cartQuantities[productCode] = desiredQty;

      const inCartEl = $(`in-cart-${productCode}`);
      if (inCartEl) {
        inCartEl.textContent = `In cart: ${desiredQty}`;
        inCartEl.style.display = desiredQty > 0 ? 'block' : 'none';
      }
      const qtyEl = $(`qty-${productCode}`);
      if (qtyEl) qtyEl.textContent = desiredQty;

      const row = $(`product-${productCode}`);
      if (row) row.classList.toggle('in-cart', desiredQty > 0);

      await updateCartBadge?.();
      updateQuantityButtons?.(productCode);
      updateAddToCartButton?.(productCode);

      const productName = product?.name || productCode;
      showSuccessMessage?.(`${productName} updated (In cart: ${desiredQty})`);
    } else {
      throw new Error(data.error || 'Failed to add to cart');
    }
  } catch (error) {
    console.error('Error adding to cart:', error);
    showErrorMessage?.("Failed to add to cart: " + (error.message || error));
  }
}



async function updateCartBadge() {
  try {
    const customer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
    const params = new URLSearchParams({
      user_id: localStorage.getItem("user_id"),
      client_id: localStorage.getItem("client_id"),
      customer_name: customer.name || 'Guest'
    });

    const response = await fetch(`/api/cart/get/?${params}`);
    const data = await response.json();

    let totalQuantity = 0;
    let itemCount = 0;

    if (data.success && data.cart && data.cart.items) {
      itemCount = data.cart.items.length;  // unique items
      totalQuantity = data.cart.items.reduce((sum, item) => sum + item.quantity, 0);
    }

    // Show as "items | quantity"
    const badge = $('cartBadge');
    if (badge) badge.textContent = `${itemCount} | ${totalQuantity}`;
  } catch (error) {
    console.error('Error updating cart badge:', error);

    // Fallback ONLY if API fails
    const sessionTotal = Object.values(cartQuantities).reduce((sum, qty) => sum + qty, 0);
    const badge = $('cartBadge');
    if (badge) badge.textContent = sessionTotal;
  }
}

// Replace the updateProductHighlights function with this corrected version
async function updateProductHighlights() {
  try {
    const customer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
    const params = new URLSearchParams({
      user_id: localStorage.getItem('user_id'),
      client_id: localStorage.getItem('client_id'),
      customer_name: customer.name || 'Guest'
    });

    const response = await fetch(`/api/cart/get/?${params}`);
    const data = await response.json();

    const existingCart = {};
    if (data.success && data.cart && data.cart.items) {
      data.cart.items.forEach(item => {
        existingCart[item.product_code] = item.quantity;
      });
    }

    // Check URL parameters to see if we're in edit mode
    const urlParams = new URLSearchParams(window.location.search);
    const isEditMode = urlParams.get('mode') === 'edit';

    // Only use editing order data if we're explicitly in edit mode
    if (isEditMode) {
      const editingOrder = JSON.parse(localStorage.getItem('editing_order') || 'null');
      const editingOrderCart = JSON.parse(localStorage.getItem('editing_order_cart') || '[]');

      // If editing an order, use the items from that order
      if (editingOrder && editingOrderCart.length > 0) {
        editingOrderCart.forEach(item => {
          existingCart[item.product_code] = item.quantity;
        });
      }
    }

    products.forEach(p => {
      if (!p.code) return;

      // Get quantity from existing cart or editing order (if in edit mode)
      const qty = (existingCart[p.code] || 0);

      // Update UI elements
      const row = $(`product-${p.code}`);
      if (row) row.classList.toggle('in-cart', qty > 0);

      const inCartEl = $(`in-cart-${p.code}`);
      if (inCartEl) {
        if (qty > 0) {
          inCartEl.textContent = `In cart: ${qty}`;
          inCartEl.style.display = 'block';
        } else {
          inCartEl.style.display = 'none';
        }
      }

      // Update internal state
      serverCartQuantities[p.code] = qty;
      selectedQuantities[p.code] = qty;

      const qtyEl = $(`qty-${p.code}`);
      if (qtyEl) qtyEl.textContent = qty;

      updateQuantityButtons?.(p.code);
      updateAddToCartButton?.(p.code);
    });
  } catch (error) {
    console.error('Error updating product highlights:', error);
    // Fallback to session items only
    products.forEach(p => {
      if (!p.code) return;
      const qty = cartQuantities[p.code] || 0;

      const row = $(`product-${p.code}`);
      if (row) row.classList.toggle('in-cart', qty > 0);
      const inCartEl = $(`in-cart-${p.code}`);
      if (inCartEl) {
        if (qty > 0) {
          inCartEl.textContent = `In cart: ${qty}`;
          inCartEl.style.display = 'block';
        } else {
          inCartEl.style.display = 'none';
        }
      }
    });
  }
}

async function clearCart() {
  try {
    const customer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
    const clearData = {
      user_id: localStorage.getItem('user_id'),
      client_id: localStorage.getItem('client_id'),
      customer_name: customer.name || 'Guest'
    };

    const response = await fetch('/api/cart/clear/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(clearData)
    });

    const data = await response.json();
    if (data.success) {
      products.forEach(product => { if (product.code) { cartQuantities[product.code] = 0; selectedQuantities[product.code] = 0; } });
      updateCartBadge();
      updateProductHighlights();
      loadProducts();
      showSuccessMessage("Cart cleared successfully");
    } else {
      throw new Error(data.error || 'Failed to clear cart');
    }
  } catch (error) {
    console.error('Error clearing cart:', error);
    showErrorMessage("Failed to clear cart: " + error.message);
  }
}

/* =========================
   Search / Pagination
========================= */
function searchProduct() {
  const input = $('searchInput');
  searchTerm = (input ? input.value : '').trim().toLowerCase();
  const clearBtn = $('clearSearchBtn');
  if (clearBtn) clearBtn.style.display = searchTerm ? 'block' : 'none';
  if (!searchTerm) { clearSearch(); return; }
  isSearching = true; loadProducts();
}
function clearSearch() {
  searchTerm = ''; isSearching = false;
  const input = $('searchInput');
  const clearBtn = $('clearSearchBtn');
  if (input) input.value = '';
  if (clearBtn) clearBtn.style.display = 'none';
  currentPage = 1; loadProducts(); setupPagination();
}
function setupPagination() {
  const paginationDiv = $('pagination');
  if (!paginationDiv) return;
  paginationDiv.innerHTML = '';
  if (products.length <= itemsPerPage) return;

  const totalPages = Math.ceil(products.length / itemsPerPage);
  const maxVisibleButtons = 5;
  let startPage, endPage;

  if (totalPages <= maxVisibleButtons) {
    startPage = 1; endPage = totalPages;
  } else {
    const maxBefore = Math.floor(maxVisibleButtons / 2);
    const maxAfter = Math.ceil(maxVisibleButtons / 2) - 1;
    if (currentPage <= maxBefore) { startPage = 1; endPage = maxVisibleButtons; }
    else if (currentPage + maxAfter >= totalPages) { startPage = totalPages - maxVisibleButtons + 1; endPage = totalPages; }
    else { startPage = currentPage - maxBefore; endPage = currentPage + maxAfter; }
  }

  const prevButton = document.createElement('button');
  prevButton.innerHTML = '&laquo;';
  prevButton.disabled = currentPage === 1;
  prevButton.onclick = () => { if (currentPage > 1) { currentPage--; loadProducts(); setupPagination(); } };
  paginationDiv.appendChild(prevButton);

  for (let i = startPage; i <= endPage; i++) {
    const pageButton = document.createElement('button');
    pageButton.textContent = i;
    if (i === currentPage) pageButton.classList.add('active');
    pageButton.onclick = () => { currentPage = i; loadProducts(); setupPagination(); };
    paginationDiv.appendChild(pageButton);
  }

  const nextButton = document.createElement('button');
  nextButton.innerHTML = '&raquo;';
  nextButton.disabled = currentPage === totalPages;
  nextButton.onclick = () => { if (currentPage < totalPages) { currentPage++; loadProducts(); setupPagination(); } };
  paginationDiv.appendChild(nextButton);
}
function updatePageInfo() {
  const pageInfoDiv = $('pageInfo');
  if (!pageInfoDiv) return;
  if (products.length <= itemsPerPage) {
    pageInfoDiv.innerHTML = `Showing all ${products.length} items`;
  } else {
    const startIndex = (currentPage - 1) * itemsPerPage + 1;
    const endIndex = Math.min(currentPage * itemsPerPage, products.length);
    pageInfoDiv.innerHTML = `Showing items ${startIndex} to ${endIndex} of ${products.length}`;
  }
}

/* =========================
   Customer selection / Popup
========================= */
function toggleCustomerDropdown(force = null) {
  const dropdown = $('customerDropdown');
  const arrow = document.querySelector('.dropdown-arrow');
  const input = $('customerSelector');

  if (!dropdown || !arrow || !input) return;

  const open = (force === null) ? dropdown.style.display !== 'block' : force;
  dropdown.style.display = open ? 'block' : 'none';
  arrow.classList.toggle('open', open);
  input.setAttribute('aria-expanded', open);
  if (open) {
    const search = document.querySelector('.dropdown-search input');
    if (search) search.focus();
  }
}

function selectCustomer(customer) {
  // Check if any products already exist in cart before switching
  const currentCart = Object.values(cartQuantities || {}).reduce((a, b) => a + b, 0);
  if (currentCart > 0) {
    showErrorMessage("‚ö†Ô∏è You already have products added. Please refresh before changing customer.");
    return;
  }

  localStorage.setItem('selected_customer', JSON.stringify(customer));
  const n = $('displayCustomerName');
  const p = $('displayCustomerPhone');
  const a = $('displayCustomerPlace');
  if (n) n.textContent = customer.name  || '';
  if (p) p.textContent = customer.phone || '';
  if (a) a.textContent = customer.place || customer.address || '';

  localStorage.setItem('cartData', JSON.stringify({ [customer.name]: {} }));
  loadCartFromLocalStorage();
  toggleCustomerDropdown(false);
}


function isCustomerSelected() {
  const savedCustomer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
  return !!savedCustomer.name;
}

function disableProductActions(disabled) {
  const buttons = document.querySelectorAll('.quantity-controls button, .add-to-cart-btn');
  buttons.forEach(btn => btn.disabled = disabled);
}

function showCustomerPopup() {
  const popup = $('customerPopup');
  if (popup) {
    popup.style.display = 'flex';
    const name = $('customerName');
    if (name) name.focus();
  }
}
function hideCustomerPopup() {
  const popup = $('customerPopup');
  if (popup) popup.style.display = 'none';
  if ($('customerName')) $('customerName').value = '';
  if ($('customerPlace')) $('customerPlace').value = '';
  if ($('customerPhone')) $('customerPhone').value = '';
}
function saveNewCustomer() {
  const name  = ($('customerName')?.value || '').trim();
  const place = ($('customerPlace')?.value || '').trim();
  const phone = ($('customerPhone')?.value || '').trim();

  if (!name) { showErrorMessage('Customer name is required'); return; }

  const newCustomer = { name: name, address: place, phone: phone };

  // add to in-memory + local manual list
  customerList.push(newCustomer);
  localStorage.setItem('manual_customers',
    JSON.stringify((JSON.parse(localStorage.getItem('manual_customers') || '[]')).concat([newCustomer]))
  );

  // update dropdown & select immediately
  populateCustomerDropdown(customerList);
  selectCustomer(newCustomer);
  hideCustomerPopup();
  showSuccessMessage('Customer added successfully');
}

function populateCustomerDropdown(customers) {
  const container = document.querySelector('.dropdown-items-container');
  if (!container) return;
  container.innerHTML = '';

  if (customers.length === 0) {
    container.innerHTML = '<div class="no-results">No customers found</div>';
    return;
  }

  // ‚úÖ Sort customers by name alphabetically
  customers.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));

  customers.forEach(customer => {
    const item = document.createElement('div');
    item.className = 'dropdown-item';
    item.setAttribute('role', 'option');
    item.setAttribute('tabindex', '0');
    item.innerHTML = `<div class="customer-name">${customer.name}</div>`;
    item.addEventListener('click', () => selectCustomer(customer));
    item.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        selectCustomer(customer);
      }
    });
    container.appendChild(item);
  });
}


async function fetchCustomers() {
  try {
    const token = localStorage.getItem('access_token');
    const response = await fetch('/customers/', { headers: { 'Authorization': `Bearer ${token}` } });
    if (response.ok) customerList = await response.json(); else customerList = [];

    // merge manual customers
    const manualCustomers = JSON.parse(localStorage.getItem('manual_customers') || '[]');
    customerList = customerList.concat(manualCustomers);

    populateCustomerDropdown(customerList);

    // restore previously selected customer
    const savedCustomer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
    if (savedCustomer.name) selectCustomer(savedCustomer);
  } catch (error) {
    console.error('Error fetching customers:', error);
    customerList = JSON.parse(localStorage.getItem('manual_customers') || '[]');
    populateCustomerDropdown(customerList);
  }
}

function setupCustomerDropdown() {
  const customerInput  = $('customerSelector');
  const dropdownArrow  = document.querySelector('.dropdown-arrow');

if (customerInput) {
  // clicking text field ‚Üí open dropdown list
  customerInput.addEventListener('click', function (e) {
    e.stopPropagation();
    toggleCustomerDropdown(true);
  });
}
if (dropdownArrow) {
  // clicking search icon ‚Üí open manual entry popup
  dropdownArrow.addEventListener('click', function (e) {
    e.stopPropagation();
    showCustomerPopup();
  });
}


  // Popup buttons
  $('saveCustomerBtn')?.addEventListener('click', saveNewCustomer);
  $('cancelPopupBtn')?.addEventListener('click', hideCustomerPopup);

  // ESC closes popup
  document.addEventListener('keydown', e => { if (e.key === 'Escape') hideCustomerPopup(); });

  // ESC also closes price popup
  document.addEventListener('keydown', e => { if (e.key === 'Escape') closePricePopup(); });

  // Click outside price popup closes it
  $('pricePopup')?.addEventListener('click', function(e) {
    if (e.target === this) closePricePopup();
  });

  // Enter submits in name
  $('customerName')?.addEventListener('keydown', function(e) { if (e.key === 'Enter') { saveNewCustomer(); } });

  // search inside dropdown
  const search = document.querySelector('.dropdown-search input');
  if (search) {
    search.addEventListener('input', function(e) {
      const keyword = e.target.value.toLowerCase();
      const filtered = customerList.filter(c =>
        c.name.toLowerCase().includes(keyword) ||
        (c.phone && c.phone.toLowerCase().includes(keyword))
      );
      populateCustomerDropdown(filtered);
    });
  }

  // outside click closes dropdown (desktop)
  document.addEventListener('click', e => {
    const container = document.querySelector('.customer-dropdown-container');
    if (container && !container.contains(e.target)) toggleCustomerDropdown(false);
  });

  // ESC closes dropdown (desktop)
  document.addEventListener('keydown', e => { if (e.key === 'Escape') toggleCustomerDropdown(false); });
}

/* =========================
   Cross-tab + focus refresh
========================= */
function handleStorageEvent(e) {
  // If other tabs modify cart or selected customer, refresh highlights + badge
  if (e.key === 'cartData' || e.key === 'selected_customer') {
    updateProductHighlights();
    updateCartBadge();
  }
}
function handleWindowFocus() {
  // Refresh when user returns to tab
  updateProductHighlights();
  updateCartBadge();
}

/* On browser BFCache restore */
window.addEventListener('pageshow', function() {
  updateProductHighlights();
  updateCartBadge();
});

/* =========================
   Boot
========================= */
document.addEventListener('DOMContentLoaded', function () {
  const dateEl = $('currentDate');
  if (dateEl) dateEl.textContent = new Date().toLocaleDateString();

  // Reset for new order if ?mode=new; keep context if ?mode=edit
  const urlParams = new URLSearchParams(window.location.search);
  const mode = urlParams.get("mode");
  const preselect = urlParams.get("preselect");

  if (mode === null) {
    localStorage.removeItem('selected_customer');
    localStorage.removeItem('cartData');
    disableProductActions(true);
  } else {
    disableProductActions(false);
  }

  // start
  fetchProducts();
  fetchCustomers();
  setupCustomerDropdown();
  initPriceSelector();    

  window.addEventListener('storage', handleStorageEvent);
  window.addEventListener('focus', handleWindowFocus);

  const userId = localStorage.getItem("user_id") || "Guest";
  const clientId = localStorage.getItem("client_id") || "CLIENT_001";
  const li = $('loginInfo');
  if (li) li.innerText = `Welcome ${userId} | ${clientId}`;

  $('searchInput')?.addEventListener('keypress', function (e) {
    if (e.key === 'Enter') searchProduct();
  });

  // If a product code was preselected from the dashboard modal, focus it
  if (preselect) {
    const tryFocus = () => {
      if (!products || products.length === 0) { setTimeout(tryFocus, 150); return; }
      const code = preselect;
      const row = $(`product-${code}`);
      if (row) {
        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // prime quantity to 1 and enable add-to-cart
        selectedQuantities[code] = Math.max(1, selectedQuantities[code] || 0);
        updateQuantityDisplay(code);
        updateQuantityButtons(code);
        updateAddToCartButton(code);
        row.classList.add('in-cart');
      } else {
        // If not on current page, force search to bring it into view
        const input = $('searchInput');
        if (input) { input.value = code; }
        searchTerm = code.toLowerCase();
        isSearching = true;
        loadProducts();
        setTimeout(tryFocus, 150);
      }
    };
    tryFocus();
  }
});


function placeOrder() {
  const editingOrder = JSON.parse(localStorage.getItem('editing_order') || 'null');
  let allOrders = JSON.parse(localStorage.getItem('orders_all') || '[]');

  // Build items from cartQuantities (mirrors server after add)
  const items = Object.entries(cartQuantities).map(([code, qty]) => {
    const product = products.find(p => p.code === code);
    return {
      id: code,
      code,
      name: product?.name || code,
      price: product?.displayPrice || 0,
      quantity: qty,
      total: (product?.displayPrice || 0) * qty
    };
  }).filter(i => i.quantity > 0);

  const totalQty = items.reduce((s, i) => s + i.quantity, 0);
  const totalAmt = items.reduce((s, i) => s + i.total, 0);

  if (editingOrder) {
    // update existing order
    const idx = allOrders.findIndex(o => o.serialNo === editingOrder.orderId);
    if (idx !== -1) {
      allOrders[idx].items = items;
      allOrders[idx].quantity = totalQty;
      allOrders[idx].amount = totalAmt;
    }
  } else {
    // create new order
    const newOrder = {
      id: Date.now(),
      serialNo: "ORD-" + Date.now(),
      customer: getCurrentCustomerName(),
      phone: JSON.parse(localStorage.getItem('selected_customer') || '{}').phone || '',
      orderDate: new Date().toLocaleDateString(),
      items,
      quantity: totalQty,
      amount: totalAmt
    };
    allOrders.push(newOrder);
  }

  localStorage.setItem('orders_all', JSON.stringify(allOrders));
  localStorage.removeItem('editing_order'); // cleanup

  showSuccessMessage("‚úÖ Order saved!");
  window.location.href = "/"; // back to dashboard
}
</script>

</body>
</html>