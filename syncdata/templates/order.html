

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Order Management System</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
    --primary-color: #1976d2;
    --secondary-color: #4caf50;
    --accent-color: #2196f3;
    --danger-color: #f44336;
    --text-color: #333;
    --light-text: #e1f5fe;
    --border-color: #e3f2fd;
    --shadow-color: rgba(0, 100, 200, 0.1);
    --success-color: #4caf50;
    --warning-color: #ff5722;
}

* { box-sizing: border-box; }

body {
    font-family: 'Segoe UI', Arial, sans-serif;
    margin: 0;
    padding: 10px;
    background-color: #f8fbff;
    min-height: 100vh;
    color: var(--text-color);
    line-height: 1.5;
}

.container {
    max-width: 100%;
    margin: 0 auto;
    background-color: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 10px var(--shadow-color);
    border: 1px solid var(--border-color);
}

.header {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-bottom: 20px;
    padding: 20px;
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
    color: white;
    border-radius: 8px;
    margin: -15px -15px 20px -15px;
}

.logo {
    font-size: 24px;
    font-weight: bold;
    color: white;
    text-align: center;
    margin: 0;
}

.customer-info { text-align: center; font-size: 14px; }
.customer-info p { margin: 5px 0; color: var(--light-text); }

.cart-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    gap: 15px;
    flex-wrap: wrap;
}

.back-button {
    padding: 8px 15px;
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
}
.back-button:hover { background-color: #1565c0; transform: translateY(-1px); }

.customer-selector { position: relative; flex-grow: 1; min-width: 200px; }
.customer-dropdown-container { position: relative; }

.customer-dropdown-container input {
    width: 100%;
    padding: 10px 40px 10px 12px;
    border: 2px solid var(--accent-color);
    border-radius: 6px;
    font-size: 14px;
    background-color: white;
    color: var(--text-color);
    transition: all 0.3s;
    height: 42px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
.customer-dropdown-container input:focus {
    outline: none;
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
}

.dropdown-arrow {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--primary-color);
    font-size: 14px;
    pointer-events: auto;
    cursor: pointer;
    transition: transform 0.2s;
}
.dropdown-arrow.open { transform: translateY(-50%) rotate(180deg); }

.custom-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 0 0 6px 6px;
    max-height: 350px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    margin-top: -1px;
}
.custom-dropdown.show { display: block; }

.dropdown-search {
    padding: 8px;
    background: white;
    position: sticky;
    top: 0;
    border-bottom: 1px solid var(--border-color);
}
.dropdown-search input {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 14px;
}
.dropdown-items-container { max-height: 300px; overflow-y: auto; }
.dropdown-item {
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
    transition: background-color 0.2s;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.dropdown-item:hover { background-color: #f5f5f5; }
.dropdown-item.selected { background-color: var(--border-color); }
.customer-name { font-weight: 600; color: var(--primary-color); font-size: 14px; }
.customer-details { font-size: 12px; color: #666; margin-top: 3px; }
.no-results { padding: 12px; color: #666; text-align: center; font-style: italic; }

.cart-icon { text-decoration: none; font-size: 24px; position: relative; color: var(--primary-color); transition: transform 0.2s; }
.cart-icon:hover { transform: scale(1.1); }
.cart-badge {
    position: absolute; top: -8px; right: -10px;  min-width: 35px;
    padding: 2px 6px;
    font-size: 12px;
    background-color: var(--danger-color); color: white;
    border-radius: 50%; padding: 2px 6px; font-size: 12px; min-width: 20px; text-align: center;
}

.search-bar { margin: 20px 0; display: flex; flex-direction: column; gap: 10px; }
.search-bar input {
    width: 100%; padding: 12px; font-size: 16px; border-radius: 8px;
    border: 2px solid var(--accent-color); background-color: white; transition: border-color 0.3s;
}
.search-bar input:focus { outline: none; border-color: var(--secondary-color); }
.search-bar button {
    padding: 12px 20px;
    background: linear-gradient(135deg, var(--accent-color) 0%, var(--secondary-color) 100%);
    color: white; border: none; border-radius: 8px; cursor: pointer; transition: transform 0.2s;
    font-size: 16px; font-weight: bold;
}
.search-bar button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
#clearSearchBtn { background: linear-gradient(135deg, var(--danger-color) 0%, #e57373 100%); }

.product-list { display: flex; flex-direction: column; gap: 15px; margin-bottom: 30px; }
.product-row {
    display: flex; align-items: center; background-color: white; border: 1px solid var(--border-color);
    border-radius: 8px; padding: 15px; box-shadow: 0 2px 8px var(--shadow-color); transition: all 0.2s;
}
/* Only lighten on hover when it's NOT in the cart */
.product-row:not(.in-cart):hover {
  transform: translateY(-2px);
  box-shadow: 0 2px 8px var(--shadow-color) !important;
  border-color: var(--border-color) !important;
}

/* Keep the green highlight only for real in-cart items */
.product-row.in-cart {
  background-color: #e8f5e9;
  border-left: 4px solid var(--secondary-color);
}
.product-row.in-cart:hover {
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.2) !important;
  border-color: var(--secondary-color) !important;
}

.product-row.in-cart { background-color: #e8f5e9; border-left: 4px solid var(--secondary-color); animation: highlight 0.5s ease; }
@keyframes highlight { from { background-color:#e8f5e9 } 50% { background-color:#c8e6c9 } to { background-color:#e8f5e9 } }

.product-details { flex-grow: 1; min-width: 0; }
.product-name { font-size: 16px; font-weight: 600; color: var(--primary-color); margin-bottom: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.product-description { font-size: 14px; color: #555; margin-bottom: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.product-specs { font-size: 13px; color: #777; margin-bottom: 10px; }
.product-price { font-size: 18px; font-weight: bold; color: var(--secondary-color); }

.product-actions { display: flex; align-items: center; gap: 10px; flex-shrink: 0; }
.quantity-controls { display: flex; align-items: center; gap: 8px; }
.quantity-controls button {
    width: 30px; height: 30px; border: 2px solid var(--accent-color); background-color: white; color: var(--accent-color);
    border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; transition: all 0.2s;
}
.quantity-controls button:hover {
    background: linear-gradient(135deg, var(--accent-color) 0%, var(--secondary-color) 100%);
    color: white; border-color: var(--secondary-color);
}
.quantity-controls button:disabled { border-color: #ccc; color:#ccc; cursor: not-allowed; background: white; }

.quantity-display {
    background: linear-gradient(135deg, #f3f9ff 0%, #e8f8f5 100%);
    padding: 5px 10px; border-radius: 8px; font-weight: bold; min-width: 50px; text-align: center; color: var(--primary-color);
    border: 2px solid var(--accent-color); font-size: 14px; cursor: pointer; transition: all 0.2s;
}
.quantity-display:hover { background: linear-gradient(135deg, #e3f2fd 0%, #d4edf7 100%); }
.quantity-input {
  background: linear-gradient(135deg, #f3f9ff 0%, #e8f8f5 100%);
  padding: 5px 10px;
  border-radius: 8px;
  font-weight: bold;
  width: 200px;  /* ‚Üê increased from 50px to 100px */
  text-align: center;
  color: var(--primary-color);
  border: 2px solid var(--accent-color);
  font-size: 14px;
  outline: none;
}
.quantity-display {
  min-width: 100px !important;
}
.quantity-input {
  width: 100px !important;
}

/* Bigger Add to Cart button */
.add-to-cart-btn {
  padding: 10px 20px !important; /* more padding for bigger click area */
  background: linear-gradient(135deg, var(--warning-color) 0%, #8f2808 100%) !important;
  color: white !important;
  border: none !important;
  border-radius: 8px !important;
  cursor: pointer !important;
  font-size: 16px !important;
  font-weight: bold !important;
  transition: all 0.2s !important;
  box-shadow: 0 3px 8px rgba(255, 87, 34, 0.35) !important;
  width: 160px !important;  /* bigger width */
  height: 48px !important;  /* taller */
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  position: relative !important;
}

/* Hover effect */
.add-to-cart-btn:hover {
  transform: translateY(-2px) !important;
  box-shadow: 0 5px 12px rgba(255, 87, 34, 0.45) !important;
}

/* Add text label instead of emoji-only icon */
.add-to-cart-btn::after {
  content: "üõí Add to Cart" !important;
  font-size: 15px !important;
}

/* Disabled state */
.add-to-cart-btn:disabled {
  background: linear-gradient(135deg, #ccc 0%, #ddd 100%) !important;
  cursor: not-allowed !important;
  box-shadow: none !important;
  transform: none !important;
  opacity: 0.7 !important;
}


.success-message {
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    background: linear-gradient(135deg, var(--success-color) 0%, #66bb6a 100%);
    color: white; padding: 15px 20px; border-radius: 8px; z-index: 1000; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    animation: slideIn 0.3s ease-out; text-align: center; max-width: 90%;
}
@keyframes slideIn { from{transform:translateX(-50%) translateY(-100%); opacity:0} to{transform:translateX(-50%) translateY(0); opacity:1} }

.loading-spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid var(--accent-color);
    border-radius: 50%;
    width: 40px; height: 40px;
    animation: spin 1s linear infinite;
    margin: 20px auto;
}
@keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }

.in-cart-quantity { font-size: 13px; color: var(--success-color); font-weight: bold; margin-top: 5px; }

.pagination { display: flex; justify-content: center; margin-top: 20px; gap: 5px; flex-wrap: wrap; }
.pagination button {
    padding: 8px 12px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; transition: all 0.2s;
}
.pagination button:hover { background-color: #e0e0e0; }
.pagination button.active { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }
.pagination button:disabled { opacity: 0.5; cursor: not-allowed; }

.page-info { text-align: center; margin-top: 10px; color: #666; font-size: 14px; }

/* ‚úÖ POPUP STYLES ‚Äî now OUTSIDE media queries so they apply on mobile too */
.popup-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.5);
  display: none;               /* set to flex via JS when opened */
  align-items: center;
  justify-content: center;
  z-index: 2000;
  padding: 15px;               /* mobile breathing room */
}
.popup-content {
  background: #fff;
  padding: 20px;
  border-radius: 10px;
  width: 100%;
  max-width: 400px;
  box-shadow: 0 5px 15px rgba(0,0,0,.3);
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.popup-content h3 {
  margin: 0 0 10px 0;
  color: var(--primary-color);
  font-size: 18px;
  text-align: center;
}
.popup-content input {
  width: 100%;
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 6px;
  font-size: 16px;
}
.popup-actions {
  display: flex;
  flex-direction: column; /* stacked on mobile */
  gap: 10px;
  margin-top: 10px;
}
.popup-actions button {
  flex: 1; padding: 12px; border: 0; border-radius: 6px; font-weight: 700; color: #fff; font-size: 16px; cursor: pointer;
}
.popup-actions button:first-child { background: var(--secondary-color); }
.popup-actions button:last-child  { background: var(--danger-color); }

/* MOBILE */
@media only screen and (max-width: 768px) {
    body { padding: 8px; }
    .container { padding: 10px; }
    .header { padding: 15px; margin: -10px -10px 15px -10px; gap: 10px; }
    .logo { font-size: 20px; }
    .customer-info { font-size: 13px; }
    .cart-header { gap: 10px; }
    .customer-selector { order: 3; width: 100%; margin-top: 10px; }
    .search-bar { flex-direction: column; }
    .search-bar input, .search-bar button { width: 100%; font-size: 14px; }
    .product-row { flex-direction: column; align-items: stretch; padding: 12px; gap: 10px; }
    .product-actions { width: 100%; justify-content: space-between; margin-top: 10px; flex-direction: row; }
    .product-name { font-size: 15px; }
    .product-price { font-size: 16px; }
    .quantity-controls button { width: 28px; height: 28px; font-size: 13px; }
    .quantity-display, .quantity-input { font-size: 13px; min-width: 70px; }
    .add-to-cart-btn { width: auto; padding: 8px 12px; border-radius: 6px; }
    .add-to-cart-btn::after { content: "Add to Cart"; }
}

/* DESKTOP */
@media only screen and (min-width: 769px) {
    .container { max-width: 800px; margin: 0 auto; }
    .header { flex-direction: row; justify-content: space-between; align-items: center; padding: 20px; }
    .customer-info { text-align: right; }
    .search-bar { flex-direction: row; }
    .search-bar input { flex: 1; }
    .search-bar button { min-width: 100px; }
    .product-actions { flex-direction: column; gap: 8px; align-items: flex-end; }
    .quantity-controls { justify-content: flex-end; }
    .add-to-cart-btn { margin-top: 5px; border-radius: 8px; width: auto; padding: 8px 12px; }
    .add-to-cart-btn::after { content: "Add to Cart"; }
}

/* Hover should NOT turn items green unless they're in the cart */
.product-row:not(.in-cart):hover {
  transform: translateY(-2px);
  box-shadow: 0 2px 8px var(--shadow-color) !important;
  border-color: var(--border-color) !important;
}

/* Keep the green highlight only for real in-cart items */
.product-row.in-cart {
  background-color: #e8f5e9;
  border-left: 4px solid var(--secondary-color);
}
.product-row.in-cart:hover {
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.2) !important;
  border-color: var(--secondary-color) !important;
}
.dropdown-arrow {
  font-size: 25px;   /* increase size */
  color: var(--primary-color);  /* keep your theme color */
}
/* ======= PRICE SELECTOR: inline design ======= */
.search-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 20px;
}

.price-selector-container {
  display: flex;
  align-items: center;
  gap: 6px;
  background: #ffffff;
  border-radius: 6px;
  padding: 6px 10px;
  box-shadow: 0 0 3px rgba(0, 0, 0, 0.05);
}

.price-selector-container label {
  font-size: 14px;
  color: #333;
  font-weight: 500;
}

.price-selector-container select {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  border: 1px solid #cfe8ff;
  border-radius: 6px;
  padding: 8px 32px 8px 10px;
  font-size: 14px;
  color: #333;
  cursor: pointer;
  background-color: #f9fbff;
  transition: all 0.2s ease-in-out;
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='8'><path fill='%23333' d='M1 1l5 5 5-5'/></svg>");
  background-repeat: no-repeat;
  background-position: right 10px center;
}

.price-selector-container select:hover {
  border-color: #82c1ff;
  box-shadow: 0 0 4px rgba(130, 193, 255, 0.4);
}

.price-selector-container select:focus {
  outline: none;
  border-color: #2b8af7;
  box-shadow: 0 0 4px rgba(43, 138, 247, 0.5);
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .search-bar {
    flex-direction: column;
    align-items: stretch;
  }

  .price-selector-container {
    width: 100%;
    justify-content: flex-start;
    margin-top: 10px;
  }

  .price-selector-container label {
    min-width: 50px;
  }
}
/* Colorful editable price input */
.editable-price-group {
    display: flex;
    align-items: center;
    gap: 8px;
    width: 100%;
    justify-content: flex-end;
}

.editable-price-group label {
    font-size: 13px;
    color: var(--primary-color);
    font-weight: 700;
    white-space: nowrap;
}

.editable-price-group input,
input[id^="editablePrice-"] {
    width: 120px;
    padding: 8px 12px;
    border: 2px solid var(--accent-color);
    border-radius: 8px;
    font-size: 14px;
    text-align: right;
    font-weight: 700;
    color: var(--primary-color);
    background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
    box-shadow: 0 2px 6px rgba(255, 152, 0, 0.2);
    transition: all 0.3s;
}

.editable-price-group input:focus,
input[id^="editablePrice-"]:focus {
    outline: none;
    border-color: var(--warning-color);
    background: linear-gradient(135deg, #fff9c4 0%, #ffecb3 100%);
    box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.2);
    transform: scale(1.02);
}

.editable-price-group input:hover,
input[id^="editablePrice-"]:hover {
    border-color: var(--warning-color);
    box-shadow: 0 3px 8px rgba(255, 152, 0, 0.3);
}


</style>
</head>
<!-- Customer Popup Modal (single copy) -->
<div id="customerPopup" class="popup-overlay">
  <div class="popup-content">
    <h3>Add New Customer</h3>
    <input type="text" id="customerName" placeholder="Enter Name" required>
    <input type="text" id="customerPlace" placeholder="Enter Place">
    <input type="text" id="customerPhone" placeholder="Enter Phone">
    <div class="popup-actions">
      <button id="saveCustomerBtn">Save</button>
      <button id="cancelPopupBtn">Cancel</button>
    </div>
  </div>
</div>

<div class="container">
  <div class="header">
    <div class="logo">Order Management</div>
    <div class="customer-info">
      <p><strong>Customer Name: <span id="displayCustomerName"></span></strong></p>
      <p><span id="displayCustomerPlace"></span></p>
      <p><span id="displayCustomerPhone"></span></p>
      <p>Date: <span id="currentDate"></span></p>
    </div>
  </div>

  <div class="cart-header">
    <button onclick="confirmBack()" class="back-button">‚Üê Back</button>
    <button onclick="refreshOrderPage()" class="back-button" style="background-color:#ff5722;">‚ü≥ Refresh</button>


    <div class="customer-selector">
      <div class="customer-dropdown-container">
        <input
          type="text"
          name="customer"
          id="customerSelector"
          placeholder="Select customer..."
          required
          autocomplete="off"
          aria-autocomplete="list"
          aria-controls="customerDropdown"
          aria-expanded="false"
        />
       <div class="dropdown-arrow" tabindex="0" role="button" aria-label="Add New Customer">‚ûï</div>




        <div class="custom-dropdown" id="customerDropdown" role="listbox">
          <div class="dropdown-search">
            <input type="text" placeholder="Search customers..." aria-label="Search customers" class="dropdown-search-input" />
          </div>
          <div class="dropdown-items-container">
            <!-- Items populated dynamically -->
          </div>
        </div>
      </div>
    </div>

    <a href="{% url 'cart' %}" class="cart-icon">
      üõí
      <span id="cartBadge" class="cart-badge">0</span>
    </a>
  </div>

<div class="search-bar">
  <input
    type="text"
    id="searchInput"
    placeholder="Search Product or Enter Code (e.g., 00001)"
  />
  <button onclick="searchProduct()">Search</button>
  <button onclick="clearSearch()" id="clearSearchBtn" style="display: none;">Clear</button>

  <!-- PRICE SELECTOR: styled and aligned inline -->
  <div class="price-selector-container">
    <label for="priceSelector">Price:</label>
    <select id="priceSelector" aria-label="Select price type">
      <option value="all">All Prices</option>
      <option value="salesprice">Sales Price</option>
      <option value="bmrp">BMRP</option>
      <option value="secondprice">Second Price</option>
      <option value="thirdprice">Third Price</option>
    </select>
  </div>
</div>

<!-- Product and pagination sections remain below -->
<div class="product-list" id="productList">
  <div class="loading-spinner" id="loadingSpinner"></div>
</div>

<div class="pagination" id="pagination"></div>
<div class="page-info" id="pageInfo"></div>



 <script>
/* =========================
   State
========================= */
let products = [];
let cartQuantities = {};
let selectedQuantities = {};
let currentPage = 1;
const itemsPerPage = 10;
let isSearching = false;
let searchTerm = '';
let customerList = [];
let serverCartQuantities = {}; // { [product_code]: qty currently in the cart }


let selectedPriceKey = 'all';
const PRICE_ORDER = ['cost','salesprice','bmrp','secondprice','thirdprice','fourthprice'];



function mostCommon(arr) {
  const cnt = new Map();
  for (const v of arr) if (v) cnt.set(v, (cnt.get(v) || 0) + 1);
  let best = null, max = 0;
  for (const [k, c] of cnt) if (c > max) { best = k; max = c; }
  return best;
}

function derivePriceLabels(products) {
  const nameFields = {
    cost: 'cost_name',
    salesprice: 'sales_price_name',
    bmrp: 'bmrp_name',
    secondprice: 'secondprice_name',
    thirdprice: 'thirdprice_name',
    fourthprice: 'fourthprice_name',
  };
  const labels = {};
  for (const key of Object.keys(nameFields)) {
    const col = nameFields[key];
    const vals = (products || []).map(p => p?.batch?.[col] || '').filter(Boolean);
    labels[key] = mostCommon(vals) || '';     // if no DB name => hide tier in dropdown
  }
  return labels;
}

function rebuildPriceSelector(labels) {
  const sel = document.getElementById('priceSelector');
  if (!sel) return;
  const options = [{ key: 'all', label: 'All Prices' }];
  for (const k of PRICE_ORDER) {
    const label = labels[k];
    if (label) options.push({ key: k, label });
  }
  sel.innerHTML = options.map(o => `<option value="${o.key}">${o.label}</option>`).join('');
  if (!options.some(o => o.key === selectedPriceKey)) selectedPriceKey = 'all';
  sel.value = selectedPriceKey;
  sel.onchange = e => setSelectedPriceKey(e.target.value);
}

function priceRowHTML(batch, key, nameField) {
  const label = batch?.[nameField];
  const val = batch?.[key];
  if (!label) return ''; // no DB name => hide the tier completely
  const txt = (val != null && val !== '') ? Number(val).toLocaleString() : '‚Äî';
  return `
    <div class="price-item" data-key="${key}" style="font-size:14px; margin:2px 0;">
      <strong>${escapeHtml(label)}:</strong> ‚Çπ${txt}
    </div>`;
}


function getSelectedPriceKey(){ return selectedPriceKey; }
function setSelectedPriceKey(key){ selectedPriceKey = key || 'all'; applyPriceSelectionToProducts(); }
// Initialize editable price inputs and attach listeners
products.forEach(product => {
  if (!product.code) return;
  const input = document.getElementById(`editablePrice-${product.code}`);
  if (!input) return;

  // set initial value based on current selected price key
  const chosenKey = getSelectedPriceKey();
  const baseValue = getPriceFromBatch(product.batch, chosenKey);
  if (baseValue && baseValue !== 0) input.value = Number(baseValue).toFixed(2);
  else input.value = '';

  // store edited price in product.__edited so other code can access it
 // --- Show warning if product is already in the cart, but still allow editing ---
input.addEventListener('focus', () => {
  const inCartQty = Number(serverCartQuantities[product.code] || 0);
  if (inCartQty > 0) {
    showErrorMessage(
      `‚ö†Ô∏è "${product.name || product.code}" is already in the cart (Qty: ${inCartQty}). Editing the price will only apply to new additions.`
    );
  }
});

// --- Normal input handler: always accept typed edits ---
input.addEventListener('input', () => {
  const v = parseFloat(input.value);
  if (!product.__edited) product.__edited = {};
  product.__edited.unit_price = (!isNaN(v) && v >= 0) ? Number(v.toFixed(2)) : null;
});

});

function initPriceSelector(){
  const sel = document.getElementById('priceSelector');
  if (!sel) return;
  sel.value = selectedPriceKey;

  sel.addEventListener('change', e => {
    const newCategory = e.target.value;

    // Check if cart has any items
    const cartHasItems = Object.values(serverCartQuantities || {}).some(qty => qty > 0);
    if (cartHasItems) {
      // Revert dropdown to previous value
      e.target.value = selectedPriceKey;

      // Show warning
      showErrorMessage("‚ö†Ô∏è You already have products in your cart. Please clear the cart before changing price category.");
      return;
    }

    // If cart empty, allow change
    setSelectedPriceKey(newCategory);
  });
}

function applyPriceSelectionToProducts(){
  const chosen = getSelectedPriceKey();
  products = Array.isArray(products) ? products : [];

  products.forEach(p => {
    if (!p.code) return;
    const container = document.getElementById(`prices-${p.code}`);
    if (!container) return;

    // --- existing logic: show/hide price rows based on selected key ---
    container.querySelectorAll('.price-item').forEach(item => {
      const key = item.getAttribute('data-key');
      if (chosen === 'all') {
        item.style.display = 'block';
        item.style.fontWeight = '400';
        item.style.opacity = '1';
      } else {
        if (key === chosen) {
          item.style.display = 'block';
          item.style.fontWeight = '700';
          item.style.opacity = item.textContent.includes('‚Äî') ? '0.6' : '1';
        } else {
          item.style.display = 'none';
        }
      }
    });

    // --- NEW LOGIC: sync editable price input ---
    const editEl = document.getElementById(`editablePrice-${p.code}`);
    if (editEl) {
      if (chosen && chosen !== 'all') {
        // try exact key first
        let val = null;
        if (p.batch && p.batch[chosen] != null && p.batch[chosen] !== '') {
          const n = Number(p.batch[chosen]);
          if (!Number.isNaN(n)) val = n;
        }
        // fallback to any valid price if missing
        if (val == null) val = getPriceFromBatch(p.batch, chosen);

        editEl.value = (val != null && val !== 0) ? Number(val).toFixed(2) : '';
        // clear any previously cached manual edit, because category changed
        if (p.__edited) p.__edited.unit_price = null;
      } else {
        // if 'all' is selected, clear edit box
        editEl.value = '';
        if (p.__edited) p.__edited.unit_price = null;
      }
    }
  });
}

/* ‚úÖ Add this helper right below */
// Returns the best numeric price from a batch according to chosenKey and fallbacks.
function getPriceFromBatch(batch, chosenKey) {
  if (!batch) {
    // no batch info ‚Äî treat as zero price
    return 0;
  }

  // If a specific price key is selected (not 'all')
  if (chosenKey && chosenKey !== 'all') {
    const val = batch[chosenKey];
    if (val != null && val !== '') {
      const n = Number(val);
      if (!Number.isNaN(n)) return n;
    }
    // fall through to fallback order if selected key missing/invalid
  }

  // Fallback order for first available valid price
  const order = ['cost','salesprice','bmrp','secondprice','thirdprice','fourthprice'];
  for (const k of order) {
    const v = batch[k];
    if (v != null && v !== '') {
      const n = Number(v);
      if (!Number.isNaN(n)) return n;
    }
  }

  // nothing usable found
  return 0;
}

// Returns Number (two-decimal) or null if user did not provide a valid edited price.
// Looks at product.__edited first, then DOM input `editablePrice-<code>`.
function getEditedPrice(code) {
  if (typeof products !== 'undefined' && Array.isArray(products)) {
    const p = products.find(x => x.code === code);
    if (p && p.__edited && p.__edited.unit_price != null) {
      const v = Number(p.__edited.unit_price);
      return Number.isFinite(v) && v >= 0 ? Number(v.toFixed(2)) : null;
    }
  }
  const el = document.getElementById(`editablePrice-${code}`);
  if (!el) return null;
  const v = parseFloat(el.value);
  if (isNaN(v) || v < 0) return null;
  return Number(v.toFixed(2));
}

/* =========================
   Navigation
========================= */
function confirmBack() {
  if (confirm("Are you sure you want to go back? Unsaved changes may be lost.")) {
    window.history.back();
    clearCart();
  }
}

function refreshOrderPage() {
  if (confirm("Refreshing will clear the current customer and cart. Continue?")) {
    localStorage.removeItem('selected_customer');
    localStorage.removeItem('cartData');
    location.reload();
  }
}


/* =========================
   Util / UI helpers
========================= */
function $(id){ return document.getElementById(id); }

function getCurrentCustomerName() {
  return JSON.parse(localStorage.getItem('selected_customer') || '{}').name || 'Guest';
}
function getCustomerCart() {
  const all = JSON.parse(localStorage.getItem('cartData') || '{}');
  const cust = getCurrentCustomerName();
  if (!all[cust]) all[cust] = {};
  return all[cust];
}
function setCustomerCart(obj) {
  const all = JSON.parse(localStorage.getItem('cartData') || '{}');
  all[getCurrentCustomerName()] = obj;
  localStorage.setItem('cartData', JSON.stringify(all));
}
function escapeHtml(unsafe) {
  if (!unsafe) return '';
  return unsafe.toString()
    .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function showLoading(show) {
  const el = $('loadingSpinner');
  if (el) el.style.display = show ? 'block' : 'none';
}
function showSuccessMessage(message) {
  const successDiv = document.createElement('div');
  successDiv.className = 'success-message';
  successDiv.textContent = message;
  document.body.appendChild(successDiv);
  setTimeout(() => successDiv.remove(), 3000);
}
function showErrorMessage(message) {
  const errorDiv = document.createElement('div');
  errorDiv.className = 'success-message';
  errorDiv.style.background = 'linear-gradient(135deg, #f44336 0%, #e57373 100%)';
  errorDiv.textContent = message;
  document.body.appendChild(errorDiv);
  setTimeout(() => errorDiv.remove(), 3000);
}

/* =========================
   Products / Cart
========================= */
async function fetchProducts() {
  try {
    showLoading(true);
    const token = localStorage.getItem('access_token');
    if (!token) {
      showErrorMessage("Please login first");
      return;
    }

    const response = await fetch('/products/', {
      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(error || "Server returned an error");
    }

    const data = await response.json();
    products = (data.results || []).map(p => ({
      ...p,
      batch: p.batch || null
    }));

    // ‚úÖ Build dynamic dropdown names from DB
    const labels = derivePriceLabels(products);
    rebuildPriceSelector(labels);

    // init qty maps
    products.forEach(product => {
      if (!product.code) return;
      cartQuantities[product.code] = cartQuantities[product.code] || 0;
      selectedQuantities[product.code] = selectedQuantities[product.code] || 0;
    });

    loadCartFromLocalStorage();
    loadProducts();
    updateCartBadge();
    setupPagination();
  } catch (error) {
    console.error("Fetch error:", error);
    products = [];
    showErrorMessage(error.message || "Failed to load products");
    const list = $('productList');
    if (list) {
      list.innerHTML =
        '<div style="text-align: center; padding: 20px; color: #666;">' +
        (error.message || "Failed to load products. Please try again.") + '</div>';
    }
  } finally {
    showLoading(false);
  }
}

function loadCartFromLocalStorage() {
  // Reset current session quantities
  cartQuantities = {};
  selectedQuantities = {};
  products.forEach(p => {
    if (p.code) {
      cartQuantities[p.code] = 0;
      selectedQuantities[p.code] = 0;
    }
  });

  // Update badge + highlights from server
  updateCartBadge();
  updateProductHighlights();
}

function saveCartToLocalStorage() {
  const existing = getCustomerCart();

  // Add new selections on top of existing
  Object.keys(cartQuantities).forEach(code => {
    if (cartQuantities[code] > 0) {
      existing[code] = (existing[code] || 0) + cartQuantities[code];
    }
  });

  setCustomerCart(existing);

  // reset temp selections
  cartQuantities = {};
  selectedQuantities = {};
  products.forEach(p => {
    if (p.code) {
      cartQuantities[p.code] = 0;
      selectedQuantities[p.code] = 0;
    }
  });

  updateCartBadge();
  updateProductHighlights();
}


function loadProducts() {
  const productList = $('productList');
  if (!productList) return;
  productList.innerHTML = '';

  if (!Array.isArray(products)) { console.error("Products data is not an array!"); products = []; }

  if (products.length === 0) {
    productList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No products available</div>';
    return;
  }

  let productsToDisplay = products;
  if (isSearching && searchTerm) {
    productsToDisplay = products.filter(product =>
      (product.name && product.name.toLowerCase().includes(searchTerm)) ||
      (product.code && product.code.toLowerCase().includes(searchTerm)) ||
      (product.brand && product.brand.toLowerCase().includes(searchTerm)) ||
      (product.product && product.product.toLowerCase().includes(searchTerm))
    );
  }

  if (productsToDisplay.length === 0) {
    productList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No products found</div>';
    if ($('pagination')) $('pagination').innerHTML = '';
    if ($('pageInfo')) $('pageInfo').innerHTML = '';
    return;
  }

  let paginatedProducts = productsToDisplay;
  if (!isSearching) {
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, productsToDisplay.length);
    paginatedProducts = productsToDisplay.slice(startIndex, endIndex);
  }

  paginatedProducts.forEach(product => {
    if (!product.code) return;

    const productRow = document.createElement('div');
    productRow.className = 'product-row';
    productRow.id = `product-${product.code}`;
    if (cartQuantities[product.code] > 0) productRow.classList.add('in-cart');

    let description = '';
    if (product.product) description += product.product;
    if (product.brand) description += (description ? ' - ' : '') + product.brand;
    if (product.unit) description += (description ? ' ' : '') + product.unit;
productRow.innerHTML = `
  <div class="product-details">
    <div class="product-name">${escapeHtml(product.name || '')}</div>
    <div class="product-description">${escapeHtml(description)}</div>
    <div class="product-specs">Code: ${escapeHtml(product.code || '')}</div>

    <!-- Prices block (all shown by default) -->
<div class="product-prices" id="prices-${product.code}" style="margin-top:8px;">
  ${priceRowHTML(product.batch, 'cost', 'cost_name')}
  ${priceRowHTML(product.batch, 'salesprice', 'sales_price_name')}
  ${priceRowHTML(product.batch, 'bmrp', 'bmrp_name')}
  ${priceRowHTML(product.batch, 'secondprice', 'secondprice_name')}
  ${priceRowHTML(product.batch, 'thirdprice', 'thirdprice_name')}
  ${priceRowHTML(product.batch, 'fourthprice', 'fourthprice_name')}
</div>

<!-- Product actions with editable price placed ABOVE quantity buttons -->
<div class="product-actions" style="display:flex; flex-direction:column; align-items:flex-end; gap:8px;">

  <!-- Editable price input now ABOVE the quantity controls -->
  <div style="display:flex; gap:6px; align-items:center;">
    <label for="editablePrice-${product.code}" style="font-size:13px; color:#333;">Price (editable):</label>
    <input id="editablePrice-${product.code}" type="number" step="0.01" min="0"
           style="width:120px; padding:6px; border:1px solid #ddd; border-radius:4px;"
           placeholder="0.00" />
  </div>

  <div class="quantity-controls" style="margin-top:4px;">
    <button onclick="changeSelectedQuantity('${product.code}', -1)" ${selectedQuantities[product.code] <= 0 ? 'disabled' : ''}>-</button>
    <div class="quantity-display" id="qty-${product.code}" onclick="enableQuantityInput('${product.code}')">${selectedQuantities[product.code] || 0}</div>
    <button onclick="changeSelectedQuantity('${product.code}', 1)">+</button>
  </div>

  <button class="add-to-cart-btn" onclick="addToCart('${product.code}')"
          ${selectedQuantities[product.code] <= 0 ? 'disabled' : ''}
          title="Add ${selectedQuantities[product.code]} to Cart"></button>
</div>

`;

    productList.appendChild(productRow);
  });

  if (isSearching) {
    if ($('pagination')) $('pagination').innerHTML = '';
    if ($('pageInfo')) $('pageInfo').innerHTML = `Showing ${productsToDisplay.length} search results`;
  } else {
    setupPagination();
    updatePageInfo();
    applyPriceSelectionToProducts();
  }
}

/* =========================
   Qty editing
========================= */
function enableQuantityInput(productCode) {
  if (!isCustomerSelected()) { showErrorMessage("‚ö†Ô∏è Please select a customer first"); return; }
  const qtyElement = $(`qty-${productCode}`);
  if (!qtyElement) return;

  const currentValue = selectedQuantities[productCode] ?? 0;
  const input = document.createElement('input');
  input.type = 'number';
  input.className = 'quantity-input';
  input.value = currentValue;
  input.min = '0';
  input.step = '0.001';           // üëà allow fractional steps
  input.inputMode = 'decimal';     // mobile keyboard
  input.pattern = '[0-9]*[.]?[0-9]*';

  input.onblur     = () => updateQuantityFromInput(productCode, input);
  input.onkeypress = (e) => { if (e.key === 'Enter') updateQuantityFromInput(productCode, input); };

  qtyElement.replaceWith(input);
  input.focus(); input.select();
}

function updateQuantityFromInput(productCode, inputElement) {
  let newValue = parseFloat(inputElement.value);
  if (Number.isNaN(newValue) || newValue < 0) newValue = 0;

  // keep up to 3 decimals to match DB
  newValue = +newValue.toFixed(3);

  selectedQuantities[productCode] = newValue;

  const displayElement = document.createElement('div');
  displayElement.className = 'quantity-display';
  displayElement.id = `qty-${productCode}`;
  displayElement.textContent = newValue;
  displayElement.onclick = () => enableQuantityInput(productCode);
  inputElement.replaceWith(displayElement);

  updateQuantityButtons(productCode);
  updateAddToCartButton(productCode);
}

function changeSelectedQuantity(productCode, change) {
  if (!isCustomerSelected()) { showErrorMessage("‚ö†Ô∏è Please select a customer first"); return; }
  const newQuantity = (selectedQuantities[productCode] || 0) + change;
  if (newQuantity >= 0) {
    selectedQuantities[productCode] = newQuantity;
    updateQuantityDisplay(productCode);
    updateQuantityButtons(productCode);
    updateAddToCartButton(productCode);
  }
}
function updateQuantityDisplay(productCode) {
  const qtyElement = $(`qty-${productCode}`);
  if (qtyElement) qtyElement.textContent = selectedQuantities[productCode] || 0;
}
function updateQuantityButtons(productCode) {
  const productRow = $(`product-${productCode}`);
  if (productRow) {
    const decreaseBtn = productRow.querySelector('.quantity-controls button');
    if (decreaseBtn) decreaseBtn.disabled = (selectedQuantities[productCode] || 0) <= 0;
  }
}
function updateAddToCartButton(productCode) {
  const row = $(`product-${productCode}`);
  if (!row) return;
  const btn = row.querySelector('.add-to-cart-btn');
  if (!btn) return;

  const desired = selectedQuantities[productCode] || 0;
  const current = serverCartQuantities[productCode] || 0;
  const delta = desired - current;

  btn.disabled = delta <= 0;
  btn.title = delta > 0 ? `Add ${delta} more` : `No change`;
}

/* =========================
   Server cart sync
========================= */
/* =========================
   Server cart sync
========================= */
async function addToCart(productCode) {
  // --- require customer + explicit price category ---
  if (!isCustomerSelected()) {
    showErrorMessage("‚ö†Ô∏è Please select a customer first");
    return;
  }
  const chosenKey = getSelectedPriceKey();
  if (!chosenKey || chosenKey === 'all') {
    showErrorMessage("‚ö†Ô∏è Please select a Price Category before adding to cart");
    return;
  }

  const desiredQty = parseFloat(selectedQuantities[productCode] ?? 0);
  const currentServerQty = parseFloat(serverCartQuantities[productCode] ?? 0);
  const delta = +(desiredQty - currentServerQty).toFixed(3);

  if (delta <= 0) {
    showSuccessMessage?.("No change ‚Äî quantity already in cart");
    return;
  }

  try {
    const customer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
    const product = products.find(p => p.code === productCode);
    if (!product) { showErrorMessage("Product not found"); return; }

    // Prefer edited price (user input). Fallback to selected price key and then the fallback order.
    let chosenUnitPrice = getEditedPrice(productCode);
    if (chosenUnitPrice == null) {
      chosenUnitPrice = getPriceFromBatch(product.batch, chosenKey);
    }

    if (!Number.isFinite(chosenUnitPrice) || chosenUnitPrice < 0) chosenUnitPrice = 0;
    chosenUnitPrice = Number(chosenUnitPrice.toFixed(2));

    const cartData = {
      user_id: localStorage.getItem("user_id"),
      client_id: localStorage.getItem("client_id"),
      customer_name: customer.name || 'Guest',
      customer_phone: customer.phone || '',
      customer_address: customer.address || '',
      product_code: productCode,
      quantity: delta,
      price_key: chosenKey,
      unit_price: chosenUnitPrice
    };

    console.log("DEBUG addToCart payload:", cartData);

    const response = await fetch('/api/cart/add/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(cartData)
    });

    const data = await response.json();
    if (data.success) {
      serverCartQuantities[productCode] = desiredQty;
      cartQuantities[productCode] = desiredQty;

      const inCartEl = $(`in-cart-${productCode}`);
      if (inCartEl) {
        inCartEl.textContent = `In cart: ${desiredQty}`;
        inCartEl.style.display = desiredQty > 0 ? 'block' : 'none';
      }
      const qtyEl = $(`qty-${productCode}`);
      if (qtyEl) qtyEl.textContent = desiredQty;

      const row = $(`product-${productCode}`);
      if (row) row.classList.toggle('in-cart', desiredQty > 0);

      await updateCartBadge?.();
      updateQuantityButtons?.(productCode);
      updateAddToCartButton?.(productCode);

      const productName = product?.name || productCode;
      showSuccessMessage?.(`${productName} updated (In cart: ${desiredQty})`);
    } else {
      throw new Error(data.error || 'Failed to add to cart');
    }
  } catch (error) {
    console.error('Error adding to cart:', error);
    showErrorMessage?.("Failed to add to cart: " + (error.message || error));
  }
}



async function updateCartBadge() {
  try {
    const customer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
    const params = new URLSearchParams({
      user_id: localStorage.getItem("user_id"),
      client_id: localStorage.getItem("client_id"),
      customer_name: customer.name || 'Guest'
    });

    const response = await fetch(`/api/cart/get/?${params}`);
    const data = await response.json();

    let totalQuantity = 0;
    let itemCount = 0;

    if (data.success && data.cart && data.cart.items) {
      itemCount = data.cart.items.length;  // unique items
      totalQuantity = data.cart.items.reduce((sum, item) => sum + item.quantity, 0);
    }

    // Show as "items | quantity"
    const badge = $('cartBadge');
    if (badge) badge.textContent = `${itemCount} | ${totalQuantity}`;
  } catch (error) {
    console.error('Error updating cart badge:', error);

    // Fallback ONLY if API fails
    const sessionTotal = Object.values(cartQuantities).reduce((sum, qty) => sum + qty, 0);
    const badge = $('cartBadge');
    if (badge) badge.textContent = sessionTotal;
  }
}

// Replace the updateProductHighlights function with this corrected version
async function updateProductHighlights() {
  try {
    const customer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
    const params = new URLSearchParams({
      user_id: localStorage.getItem('user_id'),
      client_id: localStorage.getItem('client_id'),
      customer_name: customer.name || 'Guest'
    });

    const response = await fetch(`/api/cart/get/?${params}`);
    const data = await response.json();

    const existingCart = {};
    if (data.success && data.cart && data.cart.items) {
      data.cart.items.forEach(item => {
        existingCart[item.product_code] = item.quantity;
      });
    }

    // Check URL parameters to see if we're in edit mode
    const urlParams = new URLSearchParams(window.location.search);
    const isEditMode = urlParams.get('mode') === 'edit';

    // Only use editing order data if we're explicitly in edit mode
    if (isEditMode) {
      const editingOrder = JSON.parse(localStorage.getItem('editing_order') || 'null');
      const editingOrderCart = JSON.parse(localStorage.getItem('editing_order_cart') || '[]');

      // If editing an order, use the items from that order
      if (editingOrder && editingOrderCart.length > 0) {
        editingOrderCart.forEach(item => {
          existingCart[item.product_code] = item.quantity;
        });
      }
    }

    products.forEach(p => {
      if (!p.code) return;

      // Get quantity from existing cart or editing order (if in edit mode)
      const qty = (existingCart[p.code] || 0);

      // Update UI elements
      const row = $(`product-${p.code}`);
      if (row) row.classList.toggle('in-cart', qty > 0);

      const inCartEl = $(`in-cart-${p.code}`);
      if (inCartEl) {
        if (qty > 0) {
          inCartEl.textContent = `In cart: ${qty}`;
          inCartEl.style.display = 'block';
        } else {
          inCartEl.style.display = 'none';
        }
      }

      // Update internal state
      serverCartQuantities[p.code] = qty;
      selectedQuantities[p.code] = qty;

      const qtyEl = $(`qty-${p.code}`);
      if (qtyEl) qtyEl.textContent = qty;

      updateQuantityButtons?.(p.code);
      updateAddToCartButton?.(p.code);
    });
  } catch (error) {
    console.error('Error updating product highlights:', error);
    // Fallback to session items only
    products.forEach(p => {
      if (!p.code) return;
      const qty = cartQuantities[p.code] || 0;

      const row = $(`product-${p.code}`);
      if (row) row.classList.toggle('in-cart', qty > 0);
      const inCartEl = $(`in-cart-${p.code}`);
      if (inCartEl) {
        if (qty > 0) {
          inCartEl.textContent = `In cart: ${qty}`;
          inCartEl.style.display = 'block';
        } else {
          inCartEl.style.display = 'none';
        }
      }
    });
  }
}

async function clearCart() {
  try {
    const customer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
    const clearData = {
      user_id: localStorage.getItem('user_id'),
      client_id: localStorage.getItem('client_id'),
      customer_name: customer.name || 'Guest'
    };

    const response = await fetch('/api/cart/clear/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(clearData)
    });

    const data = await response.json();
    if (data.success) {
      products.forEach(product => { if (product.code) { cartQuantities[product.code] = 0; selectedQuantities[product.code] = 0; } });
      updateCartBadge();
      updateProductHighlights();
      loadProducts();
      showSuccessMessage("Cart cleared successfully");
    } else {
      throw new Error(data.error || 'Failed to clear cart');
    }
  } catch (error) {
    console.error('Error clearing cart:', error);
    showErrorMessage("Failed to clear cart: " + error.message);
  }
}

/* =========================
   Search / Pagination
========================= */
function searchProduct() {
  const input = $('searchInput');
  searchTerm = (input ? input.value : '').trim().toLowerCase();
  const clearBtn = $('clearSearchBtn');
  if (clearBtn) clearBtn.style.display = searchTerm ? 'block' : 'none';
  if (!searchTerm) { clearSearch(); return; }
  isSearching = true; loadProducts();
}
function clearSearch() {
  searchTerm = ''; isSearching = false;
  const input = $('searchInput');
  const clearBtn = $('clearSearchBtn');
  if (input) input.value = '';
  if (clearBtn) clearBtn.style.display = 'none';
  currentPage = 1; loadProducts(); setupPagination();
}
function setupPagination() {
  const paginationDiv = $('pagination');
  if (!paginationDiv) return;
  paginationDiv.innerHTML = '';
  if (products.length <= itemsPerPage) return;

  const totalPages = Math.ceil(products.length / itemsPerPage);
  const maxVisibleButtons = 5;
  let startPage, endPage;

  if (totalPages <= maxVisibleButtons) {
    startPage = 1; endPage = totalPages;
  } else {
    const maxBefore = Math.floor(maxVisibleButtons / 2);
    const maxAfter = Math.ceil(maxVisibleButtons / 2) - 1;
    if (currentPage <= maxBefore) { startPage = 1; endPage = maxVisibleButtons; }
    else if (currentPage + maxAfter >= totalPages) { startPage = totalPages - maxVisibleButtons + 1; endPage = totalPages; }
    else { startPage = currentPage - maxBefore; endPage = currentPage + maxAfter; }
  }

  const prevButton = document.createElement('button');
  prevButton.innerHTML = '&laquo;';
  prevButton.disabled = currentPage === 1;
  prevButton.onclick = () => { if (currentPage > 1) { currentPage--; loadProducts(); setupPagination(); } };
  paginationDiv.appendChild(prevButton);

  for (let i = startPage; i <= endPage; i++) {
    const pageButton = document.createElement('button');
    pageButton.textContent = i;
    if (i === currentPage) pageButton.classList.add('active');
    pageButton.onclick = () => { currentPage = i; loadProducts(); setupPagination(); };
    paginationDiv.appendChild(pageButton);
  }

  const nextButton = document.createElement('button');
  nextButton.innerHTML = '&raquo;';
  nextButton.disabled = currentPage === totalPages;
  nextButton.onclick = () => { if (currentPage < totalPages) { currentPage++; loadProducts(); setupPagination(); } };
  paginationDiv.appendChild(nextButton);
}
function updatePageInfo() {
  const pageInfoDiv = $('pageInfo');
  if (!pageInfoDiv) return;
  if (products.length <= itemsPerPage) {
    pageInfoDiv.innerHTML = `Showing all ${products.length} items`;
  } else {
    const startIndex = (currentPage - 1) * itemsPerPage + 1;
    const endIndex = Math.min(currentPage * itemsPerPage, products.length);
    pageInfoDiv.innerHTML = `Showing items ${startIndex} to ${endIndex} of ${products.length}`;
  }
}

/* =========================
   Customer selection / Popup
========================= */
function toggleCustomerDropdown(force = null) {
  const dropdown = $('customerDropdown');
  const arrow = document.querySelector('.dropdown-arrow');
  const input = $('customerSelector');

  if (!dropdown || !arrow || !input) return;

  const open = (force === null) ? dropdown.style.display !== 'block' : force;
  dropdown.style.display = open ? 'block' : 'none';
  arrow.classList.toggle('open', open);
  input.setAttribute('aria-expanded', open);
  if (open) {
    const search = document.querySelector('.dropdown-search input');
    if (search) search.focus();
  }
}

function selectCustomer(customer) {
  // Check if any products already exist in cart before switching
  const currentCart = Object.values(cartQuantities || {}).reduce((a, b) => a + b, 0);
  if (currentCart > 0) {
    showErrorMessage("‚ö†Ô∏è You already have products added. Please refresh before changing customer.");
    return;
  }

  localStorage.setItem('selected_customer', JSON.stringify(customer));
  const n = $('displayCustomerName');
  const p = $('displayCustomerPhone');
  const a = $('displayCustomerPlace');
  if (n) n.textContent = customer.name  || '';
  if (p) p.textContent = customer.phone || '';
  if (a) a.textContent = customer.place || customer.address || '';

  localStorage.setItem('cartData', JSON.stringify({ [customer.name]: {} }));
  loadCartFromLocalStorage();
  toggleCustomerDropdown(false);
}


function isCustomerSelected() {
  const savedCustomer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
  return !!savedCustomer.name;
}

function disableProductActions(disabled) {
  const buttons = document.querySelectorAll('.quantity-controls button, .add-to-cart-btn');
  buttons.forEach(btn => btn.disabled = disabled);
}

function showCustomerPopup() {
  const popup = $('customerPopup');
  if (popup) {
    popup.style.display = 'flex';
    const name = $('customerName');
    if (name) name.focus();
  }
}
function hideCustomerPopup() {
  const popup = $('customerPopup');
  if (popup) popup.style.display = 'none';
  if ($('customerName')) $('customerName').value = '';
  if ($('customerPlace')) $('customerPlace').value = '';
  if ($('customerPhone')) $('customerPhone').value = '';
}
function saveNewCustomer() {
  const name  = ($('customerName')?.value || '').trim();
  const place = ($('customerPlace')?.value || '').trim();
  const phone = ($('customerPhone')?.value || '').trim();

  if (!name) { showErrorMessage('Customer name is required'); return; }

  const newCustomer = { name: name, address: place, phone: phone };

  // add to in-memory + local manual list
  customerList.push(newCustomer);
  localStorage.setItem('manual_customers',
    JSON.stringify((JSON.parse(localStorage.getItem('manual_customers') || '[]')).concat([newCustomer]))
  );

  // update dropdown & select immediately
  populateCustomerDropdown(customerList);
  selectCustomer(newCustomer);
  hideCustomerPopup();
  showSuccessMessage('Customer added successfully');
}

function populateCustomerDropdown(customers) {
  const container = document.querySelector('.dropdown-items-container');
  if (!container) return;
  container.innerHTML = '';

  if (customers.length === 0) {
    container.innerHTML = '<div class="no-results">No customers found</div>';
    return;
  }

  // ‚úÖ Sort customers by name alphabetically
  customers.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));

  customers.forEach(customer => {
    const item = document.createElement('div');
    item.className = 'dropdown-item';
    item.setAttribute('role', 'option');
    item.setAttribute('tabindex', '0');
    item.innerHTML = `<div class="customer-name">${customer.name}</div>`;
    item.addEventListener('click', () => selectCustomer(customer));
    item.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        selectCustomer(customer);
      }
    });
    container.appendChild(item);
  });
}


async function fetchCustomers() {
  try {
    const token = localStorage.getItem('access_token');
    const response = await fetch('/customers/', { headers: { 'Authorization': `Bearer ${token}` } });
    if (response.ok) customerList = await response.json(); else customerList = [];

    // merge manual customers
    const manualCustomers = JSON.parse(localStorage.getItem('manual_customers') || '[]');
    customerList = customerList.concat(manualCustomers);

    populateCustomerDropdown(customerList);

    // restore previously selected customer
    const savedCustomer = JSON.parse(localStorage.getItem('selected_customer') || '{}');
    if (savedCustomer.name) selectCustomer(savedCustomer);
  } catch (error) {
    console.error('Error fetching customers:', error);
    customerList = JSON.parse(localStorage.getItem('manual_customers') || '[]');
    populateCustomerDropdown(customerList);
  }
}

function setupCustomerDropdown() {
  const customerInput  = $('customerSelector');
  const dropdownArrow  = document.querySelector('.dropdown-arrow');

if (customerInput) {
  // clicking text field ‚Üí open dropdown list
  customerInput.addEventListener('click', function (e) {
    e.stopPropagation();
    toggleCustomerDropdown(true);
  });
}
if (dropdownArrow) {
  // clicking search icon ‚Üí open manual entry popup
  dropdownArrow.addEventListener('click', function (e) {
    e.stopPropagation();
    showCustomerPopup();
  });
}


  // Popup buttons
  $('saveCustomerBtn')?.addEventListener('click', saveNewCustomer);
  $('cancelPopupBtn')?.addEventListener('click', hideCustomerPopup);

  // ESC closes popup
  document.addEventListener('keydown', e => { if (e.key === 'Escape') hideCustomerPopup(); });

  // Enter submits in name
  $('customerName')?.addEventListener('keydown', function(e) { if (e.key === 'Enter') { saveNewCustomer(); } });

  // search inside dropdown
  const search = document.querySelector('.dropdown-search input');
  if (search) {
    search.addEventListener('input', function(e) {
      const keyword = e.target.value.toLowerCase();
      const filtered = customerList.filter(c =>
        c.name.toLowerCase().includes(keyword) ||
        (c.phone && c.phone.toLowerCase().includes(keyword))
      );
      populateCustomerDropdown(filtered);
    });
  }

  // outside click closes dropdown (desktop)
  document.addEventListener('click', e => {
    const container = document.querySelector('.customer-dropdown-container');
    if (container && !container.contains(e.target)) toggleCustomerDropdown(false);
  });

  // ESC closes dropdown (desktop)
  document.addEventListener('keydown', e => { if (e.key === 'Escape') toggleCustomerDropdown(false); });
}

/* =========================
   Cross-tab + focus refresh
========================= */
function handleStorageEvent(e) {
  // If other tabs modify cart or selected customer, refresh highlights + badge
  if (e.key === 'cartData' || e.key === 'selected_customer') {
    updateProductHighlights();
    updateCartBadge();
  }
}
function handleWindowFocus() {
  // Refresh when user returns to tab
  updateProductHighlights();
  updateCartBadge();
}

/* On browser BFCache restore */
window.addEventListener('pageshow', function() {
  updateProductHighlights();
  updateCartBadge();
});

/* =========================
   Boot
========================= */
document.addEventListener('DOMContentLoaded', function () {
  const dateEl = $('currentDate');
  if (dateEl) dateEl.textContent = new Date().toLocaleDateString();

  // Reset for new order if ?mode=new; keep context if ?mode=edit
  const urlParams = new URLSearchParams(window.location.search);
  const mode = urlParams.get("mode");
  const preselect = urlParams.get("preselect");

  if (mode === null) {
    localStorage.removeItem('selected_customer');
    localStorage.removeItem('cartData');
    disableProductActions(true);
  } else {
    disableProductActions(false);
  }

  // start
  fetchProducts();
  fetchCustomers();
  setupCustomerDropdown();
  initPriceSelector();    

  window.addEventListener('storage', handleStorageEvent);
  window.addEventListener('focus', handleWindowFocus);

  const userId = localStorage.getItem("user_id") || "Guest";
  const clientId = localStorage.getItem("client_id") || "CLIENT_001";
  const li = $('loginInfo');
  if (li) li.innerText = `Welcome ${userId} | ${clientId}`;

  $('searchInput')?.addEventListener('keypress', function (e) {
    if (e.key === 'Enter') searchProduct();
  });

  // If a product code was preselected from the dashboard modal, focus it
  if (preselect) {
    const tryFocus = () => {
      if (!products || products.length === 0) { setTimeout(tryFocus, 150); return; }
      const code = preselect;
      const row = $(`product-${code}`);
      if (row) {
        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // prime quantity to 1 and enable add-to-cart
        selectedQuantities[code] = Math.max(1, selectedQuantities[code] || 0);
        updateQuantityDisplay(code);
        updateQuantityButtons(code);
        updateAddToCartButton(code);
        row.classList.add('in-cart');
      } else {
        // If not on current page, force search to bring it into view
        const input = $('searchInput');
        if (input) { input.value = code; }
        searchTerm = code.toLowerCase();
        isSearching = true;
        loadProducts();
        setTimeout(tryFocus, 150);
      }
    };
    tryFocus();
  }
});


function placeOrder() {
  const editingOrder = JSON.parse(localStorage.getItem('editing_order') || 'null');
  let allOrders = JSON.parse(localStorage.getItem('orders_all') || '[]');

  // Build items from cartQuantities (mirrors server after add)
  const items = Object.entries(cartQuantities).map(([code, qty]) => {
    const product = products.find(p => p.code === code);
    return {
      id: code,
      code,
      name: product?.name || code,
      price: product?.displayPrice || 0,
      quantity: qty,
      total: (product?.displayPrice || 0) * qty
    };
  }).filter(i => i.quantity > 0);

  const totalQty = items.reduce((s, i) => s + i.quantity, 0);
  const totalAmt = items.reduce((s, i) => s + i.total, 0);

  if (editingOrder) {
    // update existing order
    const idx = allOrders.findIndex(o => o.serialNo === editingOrder.orderId);
    if (idx !== -1) {
      allOrders[idx].items = items;
      allOrders[idx].quantity = totalQty;
      allOrders[idx].amount = totalAmt;
    }
  } else {
    // create new order
    const newOrder = {
      id: Date.now(),
      serialNo: "ORD-" + Date.now(),
      customer: getCurrentCustomerName(),
      phone: JSON.parse(localStorage.getItem('selected_customer') || '{}').phone || '',
      orderDate: new Date().toLocaleDateString(),
      items,
      quantity: totalQty,
      amount: totalAmt
    };
    allOrders.push(newOrder);
  }

  localStorage.setItem('orders_all', JSON.stringify(allOrders));
  localStorage.removeItem('editing_order'); // cleanup

  showSuccessMessage("‚úÖ Order saved!");
  window.location.href = "/"; // back to dashboard
}
</script>

</body>
</html>